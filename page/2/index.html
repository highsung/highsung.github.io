<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HighSung</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="start here~~">
<meta property="og:type" content="website">
<meta property="og:title" content="HighSung">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="HighSung">
<meta property="og:description" content="start here~~">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HighSung">
<meta name="twitter:description" content="start here~~">
  
    <link rel="alternate" href="/atom.xml" title="HighSung" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HighSung</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Make progress bit by bit every day</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-course/embeded/lesson_12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/25/course/embeded/lesson_12/" class="article-date">
  <time datetime="2017-03-25T08:51:00.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/course/embeded/lesson_12/">（12）Linux字符驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Linux系统的设备"><a href="#Linux系统的设备" class="headerlink" title="Linux系统的设备"></a>Linux系统的设备</h4><h4 id="Linux设备驱动开发"><a href="#Linux设备驱动开发" class="headerlink" title="Linux设备驱动开发"></a>Linux设备驱动开发</h4><h4 id="Linux字符驱动"><a href="#Linux字符驱动" class="headerlink" title="Linux字符驱动"></a>Linux字符驱动</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_12/link.png" alt="image"></p>
<h5 id="Linux系统的设备-1"><a href="#Linux系统的设备-1" class="headerlink" title="Linux系统的设备"></a>Linux系统的设备</h5><p>Linux系统中的设备分为三大类：字符设备，块设备，网络设备。字符设备就是以字节流形式通讯的I/O设备，常见的字符设备有键盘，鼠标，串口等。块设备则是以传输固定大小来访问设备。比如硬盘，U盘等等。网络设备跟块设备类似，但它能异步的接收来自外部的数据。</p>
<h5 id="Linux设备驱动开发-1"><a href="#Linux设备驱动开发-1" class="headerlink" title="Linux设备驱动开发"></a>Linux设备驱动开发</h5><p>Linux中一切皆文件。驱动程序作用就是提供上层应用访问底层硬件的桥梁作用。<br>从上层应用程序访问硬件设备的角度，Linux驱动模型必须提供一组对设备访问的操作集供上层调用之。这里主要涉及到Linux内核封装好的struct file_operations，驱动程序的编写，主要工作就是实现struct file_operations里面的方法。另外，Linux内核要提供如何管理设备的方法。比如如何申请设备编号，名字，内核数据结构，cdev数据结构。</p>
<p>先来看看操作集, struct file_operations<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">struct file_operations &#123;</div><div class="line">    struct module *owner;   //THIS_MODULE</div><div class="line">    // 读数据</div><div class="line">    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">    // 写数据</div><div class="line">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div><div class="line">    // 映射内核空间到用户空间</div><div class="line">    int (*mmap) (struct file *, struct vm_area_struct *);</div><div class="line">    // 读写设备参数、读设备状态、控制设备</div><div class="line">    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line"></div><div class="line">    // 打开设备</div><div class="line">    int (*open) (struct inode *, struct file *);</div><div class="line">    // 关闭设备</div><div class="line">    int (*release) (struct inode *, struct file *);</div><div class="line">    // 刷新设备</div><div class="line">    int (*flush) (struct file *, fl_owner_t id);</div><div class="line">    // 文件定位</div><div class="line">    loff_t (*llseek) (struct file *, loff_t, int);</div><div class="line"></div><div class="line">    // 异步通知</div><div class="line">    int (*fasync) (int, struct file *, int);</div><div class="line">    // POLL机制</div><div class="line">    unsigned int (*poll) (struct file *, struct poll_table_struct *);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>读和写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 读数据</div><div class="line">ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">// 写数据</div><div class="line">ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div></pre></td></tr></table></figure></p>
<p>read和write的buff参数是用户空间指针。因此，内核提供了专门的函数用于访问用户空间的指针，用于数据的来回“穿越”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 把数据从用户空间搬运到内核空间</div><div class="line">int copy_from_user(void *to,const void_user *from,int n)</div><div class="line">// 把数据从内核空间搬运到用户空间</div><div class="line">int copy_to_user(void_user *to,const void *from,int n)</div></pre></td></tr></table></figure></p>
<p>重要数据结构</p>
<ul>
<li>struct file<ul>
<li>代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的struct file 。它由内核在打开文件时创建，在文件关闭后释放</li>
</ul>
</li>
<li>struct inode<ul>
<li>用来记录文件的物理上的信息。因此，它和代表打开文件的file结构是不同的。一个文件可以对应多个file结构，但只有一个inode结构。</li>
</ul>
</li>
<li>struct file_operations<ul>
<li>一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数，这些函数实现一个特别的操作，对于不支持的操作保留为NULL。</li>
</ul>
</li>
</ul>
<h6 id="申请设备号"><a href="#申请设备号" class="headerlink" title="申请设备号"></a>申请设备号</h6><ul>
<li>主设备号用来标识与设备文件相连的驱动程序。</li>
<li>次设备号被驱动程序用来辨别操作的是哪个设备。<br>dev_t   其实质为unsigned int 32 位整数，其中高12位为主设备号，低20位为次设备号。<br>从dev_t 中分解主次设备号<br>主设备号 MAJOR（dev_t dev）<br>次设备号 MINOR（dev_t dev）</li>
<li><p>分配设备号</p>
<ul>
<li><p>动态申请<br>方法：使用alloc_chrdev_region分配设备号<br>优点：简单，易于驱动推广<br>缺点：无法在安装驱动前创建设备文件（因为安装前没有分配到主设备号）<br>解决办法：安装驱动后，从/proc/devices 中查询设备号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name)</div><div class="line">功能</div><div class="line">	动态申请count个设备号，第1个设备号的次设备号为  baseminor</div><div class="line">参数</div><div class="line">	dev 分配到的设备号</div><div class="line">	baseminor 起始次设备号</div><div class="line">	count 要注册的设备号个数</div><div class="line">	name 设备名</div></pre></td></tr></table></figure>
</li>
<li><p>静态申请<br>方法：通过cat /proc/devices 确定一个没有使用的主设备号，使用register_chrdev_region函数注册设备号。<br>优点：简单<br>缺点：一旦驱动被广泛使用，这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int register_chrdev_region(dev_t from,unsigned count,const char *name)</div><div class="line">功能</div><div class="line">	注册从from开始的count个设备号（主设备号不变，次设备号增加，如果此设备号溢出，主设备号加1）</div><div class="line">参数</div><div class="line">	from 要注册的第一个设备号</div><div class="line">	count 要注册的设备号个数</div><div class="line">	name 设备名</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h6 id="注销设备"><a href="#注销设备" class="headerlink" title="注销设备"></a>注销设备</h6><p>不论使用任何方法分配设备号，都应该在不使用它们时释放这些设备号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void unregister_chrdev_region(dev_t from,unsigned count)</div><div class="line">功能</div><div class="line">	释放从from 开始的count 个设备号</div></pre></td></tr></table></figure></p>
<h6 id="利用mknode命令手动创建设备节点"><a href="#利用mknode命令手动创建设备节点" class="headerlink" title="利用mknode命令手动创建设备节点"></a>利用mknode命令手动创建设备节点</h6><p>mknode用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mknod devicename type major minnor</div><div class="line"></div><div class="line">devicename 	设备文件名</div><div class="line">type 		    设备文件类型</div><div class="line">major 	    主设备号</div><div class="line">minor 	    次设备号</div><div class="line">例子：</div><div class="line">mknode ok6410sel c 232 0</div></pre></td></tr></table></figure></p>
<h4 id="Linux字符驱动和应用测试例子"><a href="#Linux字符驱动和应用测试例子" class="headerlink" title="Linux字符驱动和应用测试例子"></a>Linux字符驱动和应用测试例子</h4><p>简单的字符驱动程序mychar.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">#include &lt;linux/kernel.h&gt;</div><div class="line">#include &lt;linux/fs.h&gt;</div><div class="line">#include &lt;linux/errno.h&gt;</div><div class="line">#include &lt;linux/types.h&gt;</div><div class="line">#include &lt;linux/fcntl.h&gt;</div><div class="line">#include &lt;linux/cdev.h&gt;</div><div class="line">#include &lt;linux/version.h&gt;</div><div class="line">#include &lt;linux/vmalloc.h&gt;</div><div class="line">#include &lt;linux/ctype.h&gt;</div><div class="line">#include &lt;linux/pagemap.h&gt;</div><div class="line">#include &lt;linux/ioctl.h&gt;</div><div class="line">#include &lt;linux/slab.h&gt;</div><div class="line"></div><div class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</div><div class="line"></div><div class="line">#define DEMO_MAJOR 225</div><div class="line">#define DEMO_MINOR 0</div><div class="line">#define DEV_NAME &quot;mychar&quot;</div><div class="line"></div><div class="line">struct demo_dev &#123;</div><div class="line">	struct cdev cdev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/*</div><div class="line">尽管这常常是对设备文件进行的第一个操作， 不要求驱动声明一个对应的方法。 如果这个项是 NULL，设备打开一直成功，但是你的驱动不会得到通知。</div><div class="line">*/</div><div class="line">int test_open (struct inode *inode, struct file *filp)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter open\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">在文件结构被释放时引用这个操作。如同 open、release 可以为 NULL。</div><div class="line">*/</div><div class="line">int test_release (struct inode *inode,  struct file *filp)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter release\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">从设备中读取数据</div><div class="line">*/</div><div class="line">ssize_t test_read (struct file *filp, char __user *buf, size_t size, loff_t *offset)</div><div class="line">&#123;</div><div class="line">	printk(&quot;user buffer %s\n&quot;, buf);</div><div class="line">	printk(&quot;enter read\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">向设备发送数据</div><div class="line">*/</div><div class="line">ssize_t test_write (struct file *filp, const char __user *buf, size_t size, loff_t *offset)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter write\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制设备</div><div class="line">*/</div><div class="line">int test_ioctl (struct file *filp, unsigned int cmd, unsigned long args) &#123;</div><div class="line">	printk(&quot;enter ioctl\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;				</div><div class="line"></div><div class="line">struct demo_dev *demo_devices;</div><div class="line"></div><div class="line">static struct file_operations fos = &#123;</div><div class="line">	.owner = THIS_MODULE,</div><div class="line">	.open = test_open,</div><div class="line">	.release = test_release,</div><div class="line">	.read = test_read,</div><div class="line">	.write = test_write,</div><div class="line">	.unlocked_ioctl = test_ioctl</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static int reg_dev()</div><div class="line">&#123;</div><div class="line">	int result;</div><div class="line">	dev_t dev = 0;</div><div class="line"></div><div class="line">  // 生成设备号</div><div class="line">	dev = MKDEV(DEMO_MAJOR, DEMO_MINOR);</div><div class="line">  // 申请注册一个字符设备</div><div class="line">	result = register_chrdev_region(dev, 1, DEV_NAME);</div><div class="line">	if (result &lt; 0) &#123;</div><div class="line">		printk(KERN_WARNING &quot;DEMO: can&apos;t get major %d\n&quot;, DEMO_MAJOR);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">  // 申请设备空间</div><div class="line">	demo_devices = kmalloc(sizeof(struct demo_dev), GFP_KERNEL);</div><div class="line">	if (!demo_devices) &#123;</div><div class="line">		result = -ENOMEM;</div><div class="line">		//goto fail;</div><div class="line">	&#125;</div><div class="line">  // 设备空间清理</div><div class="line">	memset(demo_devices, 0, sizeof(struct demo_dev));</div><div class="line">  // 对设备空间赋值</div><div class="line">	cdev_init(&amp;demo_devices-&gt;cdev, &amp;fos);</div><div class="line">	demo_devices-&gt;cdev.owner = THIS_MODULE;</div><div class="line">	demo_devices-&gt;cdev.ops = &amp;fos;</div><div class="line">	//将创建的字符设备与file_operations中各函数操作连接起来</div><div class="line">	result = cdev_add(&amp;demo_devices-&gt;cdev, dev, 1);</div><div class="line">	if (result) &#123;</div><div class="line">		printk(KERN_NOTICE &quot;error %d adding demo\n&quot;, result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	printk(&quot;call init \n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void unreg_dev()</div><div class="line">&#123;</div><div class="line">	dev_t devno = MKDEV(DEMO_MAJOR, DEMO_MINOR);</div><div class="line"></div><div class="line">	if (demo_devices) &#123;</div><div class="line">		cdev_del(&amp;demo_devices-&gt;cdev);</div><div class="line">		kfree(demo_devices);</div><div class="line">	&#125;</div><div class="line">	unregister_chrdev_region(devno, 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int hello_init(void)</div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT &quot;Hello, world\n&quot;);</div><div class="line"></div><div class="line">	reg_dev();</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void hello_exit(void)</div><div class="line">&#123;</div><div class="line">	unreg_dev();</div><div class="line">	printk(KERN_ALERT &quot;Goodbye, cruel world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div></pre></td></tr></table></figure></p>
<p>应用程序测试驱动程序test_mychar.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;linux/rtc.h&gt;</div><div class="line">#include &lt;linux/ioctl.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define COMMAND1 1</div><div class="line">#define COMMAND2 2</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int fd;</div><div class="line">	int i;</div><div class="line">	char data[256] = &#123;0&#125;;</div><div class="line">	int retval;</div><div class="line"></div><div class="line">  // 1. 以读写方式打开/dev/mychar设备</div><div class="line">	fd = open(&quot;/dev/mychar&quot;, O_RDWR);</div><div class="line">	printf(&quot;fd = %d\n&quot;, fd);</div><div class="line">  // 打开失败程序退出</div><div class="line">	if (fd &lt; 0) &#123;</div><div class="line">		perror(&quot;open error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;open /dev/mychar successfully\n&quot;);</div><div class="line"></div><div class="line">  // 2. 设备io控制指令</div><div class="line">	retval = ioctl(fd, 100, 11);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;ioctl error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;ioctl command 1 successfully\n&quot;);</div><div class="line"></div><div class="line">  // 3. 向设备写入数据</div><div class="line">	retval = write(fd, &quot;testchar&quot;, 7);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;write error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">/*</div><div class="line">	retval = lseek(fd, 0, 0);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;lseek error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">*/</div><div class="line">  // 4. 从设备读取数据</div><div class="line">	retval = read(fd, data, 10);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;read error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;read successfully: %s\n&quot;, data);</div><div class="line">  // 5. 关闭设备</div><div class="line">  close(fd);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="操作结果"><a href="#操作结果" class="headerlink" title="操作结果"></a>操作结果</h6><ul>
<li>利用Makefile编译模块mychar.c，gcc编译应用程序test_mychar.c。</li>
<li><p>创建设备节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mknod /dev/mychar c 225 0</div></pre></td></tr></table></figure>
</li>
<li><p>运行a.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo ./a.out</div><div class="line">fd = 3</div><div class="line">open /dev/mychar successfully</div><div class="line">ioctl command 1 successfully</div><div class="line">read successfully:</div></pre></td></tr></table></figure>
</li>
<li><p>查看驱动打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ dmesg</div><div class="line">...</div><div class="line">[26562.470512] enter open</div><div class="line">[26562.472281] enter ioctl</div><div class="line">[26562.472302] enter write</div><div class="line">[26562.472304] user buffer</div><div class="line">[26562.472304] enter read</div><div class="line">[26562.472325] enter release</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/25/course/embeded/lesson_12/" data-id="cj4l6e295000ubhp5wrq18lke" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/24/course/embeded/lesson_11/" class="article-date">
  <time datetime="2017-03-24T13:31:00.000Z" itemprop="datePublished">2017-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/course/embeded/lesson_11/">（11）Linux模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Linux模块简介"><a href="#Linux模块简介" class="headerlink" title="Linux模块简介"></a>Linux模块简介</h4><h4 id="模块入门"><a href="#模块入门" class="headerlink" title="模块入门"></a>模块入门</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_11/link.jpg" alt="image"></p>
<h5 id="Linux模块简介-1"><a href="#Linux模块简介-1" class="headerlink" title="Linux模块简介"></a>Linux模块简介</h5><p>Linux系统按照程序运行空间（或权限）分用户空间和内核空间，内核空间运行linux内核程序代码。Linux内核代码属于单内核（monolithic kernel），其优点是运行效率高。缺点是所有的内核代码都集成一体，代码的耦合度高，可扩展性和维护性差。LKM模块机制解决了linux内核的缺陷，其提供了内核可以动态装载和卸载一些程序代码，这类代码称之为模块。</p>
<p>模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在需要运行时被动态链接到内核内存空间运行，这点和运行在用户空间的应用程序有很大不同。若一个模块程序用于管理某些硬件设备，如网卡，键盘、摄像头等，这种模块称为设备驱动模块。</p>
<h5 id="内核如何管理模块"><a href="#内核如何管理模块" class="headerlink" title="内核如何管理模块"></a>内核如何管理模块</h5><p>1、为了使内核模块访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改这些符号表；<br>2、有些模块要求利用其他模块的功能，因此，内核要维护模块之间的依赖性。<br>3、内核必须能够在卸载模块时通知模块，并且要释放分配给模块的内存和中断等资源； 　　<br>4、内核版本和模块版本的不兼容，也可能导致系统崩溃，因此，严格的版本检查是必需的。</p>
<h5 id="模块入门-1"><a href="#模块入门-1" class="headerlink" title="模块入门"></a>模块入门</h5><ol>
<li><p>来一个hello world模块程序，hello_module.c文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line"></div><div class="line">// 声明模块支持协议</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line"></div><div class="line">// 模块安装入口，被insmod命令调用</div><div class="line">int __init init_hello_module(void)</div><div class="line">&#123;</div><div class="line">    //用dmesg命令可以查看该信息</div><div class="line">    printk(&quot;Hello kernel, I am a module.\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//模块卸载出口，被rmmod命令调用</div><div class="line">void __exit cleanup_hello_module(void)</div><div class="line">&#123;</div><div class="line">    printk(&quot;Good bye kernel, from a module!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//绑定装载和卸载函数</div><div class="line">module_init(init_hello_module);</div><div class="line">module_exit(cleanup_hello_module);</div></pre></td></tr></table></figure>
</li>
<li><p>再写一个Makefile，编译module。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">obj-m := modules.o               #要生成的模块名     </div><div class="line">modules-objs:= hello_module.o     #生成这个模块名所需要的目标文件</div><div class="line"></div><div class="line">KDIR := /lib/modules/`uname -r`/build</div><div class="line">PWD := $(shell pwd)</div><div class="line"></div><div class="line">default:</div><div class="line">  make -C $(KDIR) M=$(PWD) modules</div><div class="line"></div><div class="line">clean:</div><div class="line">  rm -rf *.o .* .cmd *.ko *.mod.c .tmp_versions</div></pre></td></tr></table></figure>
<p>说明：<br>obj-m  : 指定要声称的模块名字。格式为obj-m := &lt;模块名&gt;.o<br>modules-objs：声称模块modules需要的目标文件。格式为&lt;模块名&gt;-objs := &lt;目标文件&gt;<br>切记：模块名字不能与目标文件名字相同。如在这里模块名不能取成hello_module；<br>KDIR   ：指定操作系统内核编译目录。若目录不存在通过sudo dnf install kernel-devel<br>M=     ：指定源文件的位置。<br>PWD    ：当前工作路径，通过make执行shell命令$(shell pwd)得到。</p>
</li>
<li><p>编译、安装、卸载module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">$ ls</div><div class="line">hello_module.c  Makefile    modules.mod.c  modules.o      Module.symvers</div><div class="line">hello_module.o  modules.ko  modules.mod.o  modules.order</div><div class="line">$ sudo insmod modules.ko</div><div class="line">$ sudo rmmod  modules</div><div class="line">$ demsg</div><div class="line">...</div><div class="line">[ 1186.777496] Hello kernel,I am a module.</div><div class="line">[ 1580.009145] Good bye kernel, from a module!</div></pre></td></tr></table></figure>
</li>
<li><p>安装模块后，查看其信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/modules</div><div class="line">modules 16384 0 - Live 0xffffffffc078f000 (OE)</div><div class="line">nls_utf8 16384 1 - Live 0xffffffffc0785000</div><div class="line">isofs 40960 1 - Live 0xffffffffc0776000</div><div class="line">...</div><div class="line">$ modinfo modules.ko</div><div class="line">filename:       /home/highsung/dev/lesson_11/modules.ko</div><div class="line">license:        GPL</div><div class="line">depends:        </div><div class="line">vermagic:       4.8.6-300.fc25.x86_64 SMP mod_unload</div></pre></td></tr></table></figure>
</li>
<li><p>给模块添加更多信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 作者</div><div class="line">MODULE_AUTHOR(&quot;Highsung tech,&lt;1307814956@qq.com&gt;&quot;);</div><div class="line">// 版本</div><div class="line">MODULE_VERSION(&quot;0.1&quot;);</div><div class="line">// 描述模块作用</div><div class="line">MODULE_DESCRIPTION(&quot;Just for test&quot;);</div><div class="line">// 模块别名</div><div class="line">MODULE_ALIAS(&quot;Simple module&quot;);</div><div class="line">// 模块源hash值</div><div class="line">MODULE_INFO(srcversion,&quot;123zxcv&quot;);</div><div class="line">MODULE_INFO(intree,&quot;Y&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>重新编译模块并装载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ modinfo modules.ko</div><div class="line">filename:       /home/highsung/dev/lesson_11/modules.ko</div><div class="line">intree:         Y</div><div class="line">srcversion:     123zxcv</div><div class="line">alias:          Simple module</div><div class="line">description:    Just for test</div><div class="line">version:        0.1</div><div class="line">author:         Highsung tech,&lt;1307814956@qq.com&gt;</div><div class="line">license:        GPL</div><div class="line">srcversion:     CA56BD7A1BEE0427483B64A</div><div class="line">depends:        </div><div class="line">vermagic:       4.8.6-300.fc25.x86_64 SMP mod_unload</div></pre></td></tr></table></figure></p>
<h5 id="模块传参"><a href="#模块传参" class="headerlink" title="模块传参"></a>模块传参</h5><p>在用户态的C语言中，函数的传参使用main(int argc, char* argv)，内核的传参使用了另外一种方法：<br>步骤一、在内核函数中用module_param指定模块参数。<br>步骤二、加载内核时传递参数给模块。</p>
<p>module_param函数使用方法：<br>module_param(name, type, perm)<br>name：内核参数的名称，自定义；<br>type：内核参数的类型，常见的类型byte、short、int、long、ulong、bool 、charp(字符指针);<br>perm：内核参数的权限S_IRUGO(对模块参数具有读权限)。其实权限和文件的权限差不多，具体可以查看”/usr/include/linux/stat.h”。</p>
<p>  再编写一个param_module.c模块源文件：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line"></div><div class="line">// 声明模块支持协议</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line">MODULE_AUTHOR(&quot;Highsung tech,&lt;1307814956@qq.com&gt;&quot;);</div><div class="line">MODULE_VERSION(&quot;0.1&quot;);</div><div class="line"></div><div class="line">// 定义整数和字符串</div><div class="line">int testNum = 10;</div><div class="line">char *testStr = &quot;param module&quot;;</div><div class="line"></div><div class="line">// 模块安装入口，被inmod命令调用</div><div class="line">int __init init_hello_module(void)</div><div class="line">&#123;</div><div class="line">	printk(&quot;Hello kernel,I am a module.\n&quot;);</div><div class="line">	printk(&quot;test num=%d, str=%s\n&quot;,testNum, testStr);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 模块卸载出口，被rmmod命令调用</div><div class="line">void __exit cleanup_hello_module(void)</div><div class="line">&#123;</div><div class="line">	printk(&quot;Good bye kernel, from a module!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 绑定装卸和卸载函数</div><div class="line">module_init(init_hello_module);</div><div class="line">module_exit(cleanup_hello_module);</div><div class="line">// 绑定整数和字符串</div><div class="line">module_param(testNum, int, 0644);</div><div class="line">module_param(testStr, charp, 0644);</div></pre></td></tr></table></figure></p>
<p>  卸载先前的模块，再次装载之。正确打印传入的整数和字符串。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo insmod modules.ko testNum=123 testStr=&apos;abc&apos;</div><div class="line">$ dmesg</div><div class="line">...</div><div class="line">[10389.957834] Hello kernel,I am a module.</div><div class="line">[10389.957836] test num=123, str=abc</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/24/course/embeded/lesson_11/" data-id="cj4l6e294000rbhp5ip96krhf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/course/embeded/lesson_10/" class="article-date">
  <time datetime="2017-03-23T06:04:00.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/course/embeded/lesson_10/">（10）Makefile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h4><h4 id="Makefile内部规则"><a href="#Makefile内部规则" class="headerlink" title="Makefile内部规则"></a>Makefile内部规则</h4><h4 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_10/link.png" alt="image"></p>
<h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><p>前面我们聊过了gcc编译源码的一些常用指令，当源代码很多时，逐条逐条的输入编译是一件细思极恐的事情！有没更加简单、高效的方式呢？当然有，那就是Makfile。</p>
<p>当一个工程中的源文件越来越多时，工程师通常会按类型、功能、模块分别放在若干个目录中，Makefile中定义一系列的规则来指定，那些文件先编译，那些后编译，那些文件修改后，依赖它的文件需要重新编译，甚至进行更复杂的功能操作，比如清除中间和目标文件，安装编译好的文件等。</p>
<p>总之，Makefile是用来定义整个工程的编译规则的，一旦写好，只需要一个make命令，整个工程自动完成编译，极大的提高了软件开发效率。</p>
<h5 id="Makefile内部规则-1"><a href="#Makefile内部规则-1" class="headerlink" title="Makefile内部规则"></a>Makefile内部规则</h5><p>下面是Makefile中最核心的结构：<br>target: prerequisites<br>  command<br>…<br>解释：<br>target 可以是一个目标文件，也可以是执行文件，还可以是一个标签。标签这种特性，在后面的“伪目标”介绍。</p>
<p>prerequisite 是生成target所需要的文件或目标。</p>
<p>command make需要执行命令，通过执行command来生成target。</p>
<p>总结，target依赖于prerequisites中的条件（文件），生成target的规则定义在command中，由make执行。如果prerequisites中的文件比target目标要新，command所定义的命令就会被执行。</p>
<h5 id="Makefile实例分析"><a href="#Makefile实例分析" class="headerlink" title="Makefile实例分析"></a>Makefile实例分析</h5><p>一个工程有3个头文件，8个C文件，为编译得到可执行程序。Makefile文件定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">edit: main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">  cc -o edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">main.o: main.c defs.h</div><div class="line">  cc -c main.c</div><div class="line">kbd.o: kbd.c defs.h command.h</div><div class="line">  cc -c kbd.c</div><div class="line">command.o: command.c defs.h command.h</div><div class="line">  cc -c command.c</div><div class="line">display.o: dispaly.c defs.h buffer.h</div><div class="line">  cc -c display.c</div><div class="line">insert.o: insert.c defs.h buffer.h</div><div class="line">  cc -c insert.c</div><div class="line">search.o: search.c defs.h buffer.h</div><div class="line">  cc -c search.c</div><div class="line">files.o:files.c defs.h buffer.h command.h</div><div class="line">  cc -c files.c</div><div class="line">utils.o:utils.c defs.h</div><div class="line">  cc -c utils.c</div><div class="line">clean:</div><div class="line">  rm edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>说明：<br>edit目标依赖main.o kbd.o command.o display.o insert.o search.o files.o utils.o这些文件，通过执行命令cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o，生成edit可执行文件。</p>
<p>同理，main.o目标依赖main.c defs.h这些文件，通过执行命令cc -c main.c，生成main.o文件。</p>
<p>clean目标，没有依赖文件，通过执行命令rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o达到目的。</p>
<p>Makefile中的反斜杠（\）是续行符的意思。在Linux终端切换到该目录下，执行“make”命令就可以生成可执行文件edit。如果要删除可执行文件和所有中间文件，执行“make clean”就可以了。</p>
<h6 id="注意：命令行必须以Tab键开头，不然make会报错。"><a href="#注意：命令行必须以Tab键开头，不然make会报错。" class="headerlink" title="注意：命令行必须以Tab键开头，不然make会报错。"></a>注意：命令行必须以Tab键开头，不然make会报错。</h6><h5 id="make命令-1"><a href="#make命令-1" class="headerlink" title="make命令"></a>make命令</h5><ol>
<li><p>make命令用法<br>makefile有点像Shell脚本一样，它是靠make命令解释执行的。make命令是GNU的工程化编译工具。<br>make命令语法：make [选项] 参数 Makefile名<br>-f：指定“makefile”文件；<br>-i：忽略命令执行返回的出错信息；<br>-s：沉默模式，在执行之前不输出相应的命令行信息；<br>-r：禁止使用build-in规则；<br>-n：非执行模式，输出所有执行命令，但并不执行；<br>-t：更新目标文件；<br>-q：make操作将根据目标文件是否已经更新返回”0”或非”0”的状态信息；<br>-p：输出所有宏定义和目标文件描述；<br>-d：Debug模式，输出有关文件和检测时间的详细信息。<br>-c dir：在读取 makefile 之前改变到指定的目录dir；<br>-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；<br>-h：help文挡，显示所有的make选项；<br>-w：在处理 makefile 之前和之后，都显示工作目录。</p>
</li>
<li><p>make如何工作</p>
</li>
</ol>
<ul>
<li>默认情况下，我们输入make命令，那么make会在当前目录下找名字为“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找到文件中的第一个目标执行。在上面的例子中，第一个目标就是edit。<br>如果找不到makefile则提示“无目标”。</li>
<li>如果edit不存在，或edit所依赖的.o文件修改时间比edit文件新，那么执行后面所定义的命令来生成edit文件。</li>
<li>各个.o文件同理类推。</li>
</ul>
<h5 id="改进makefile"><a href="#改进makefile" class="headerlink" title="改进makefile"></a>改进makefile</h5><ul>
<li>变量的使用<br>先看看第一个target<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">edit: main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">  cc -o edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有重复两次的main.o kbd.o command.o display.o insert.o search.o files.o utils.o。<br>定义一个变量来代替它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">cc -o edit $objects</div></pre></td></tr></table></figure></p>
<p>是不是简洁一点了。</p>
<ul>
<li>使用make自动推到功能<br>GNU的make会自动推导文件以及依赖关系后面的命令。换句话说，make看到something.o时，会自动推导出cc -c something.c命令出来。所以上面的makefile可以写成：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">  cc -o $objects</div><div class="line">main.o: defs.h</div><div class="line">kbd.o: defs.h command.h</div><div class="line">command.o: defs.h command.h</div><div class="line">display.o: defs.h buffer.h</div><div class="line">insert.o: defs.h buffer.h</div><div class="line">search.o: defs.h buffer.h</div><div class="line">files.o: defs.h buffer.h command.h</div><div class="line">utils.o: defs.h</div><div class="line">clean:</div><div class="line">  rm edit $objects</div></pre></td></tr></table></figure>
</li>
</ul>
<p>是不是更简洁了。</p>
<ul>
<li>使用make隐式规则进行到底<br>现在看到还有一堆的.h文件，再次收拢变成<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">  cc -o $objects</div><div class="line">$objects:defs.h kbd.o command.o files.o:command.h \</div><div class="line">dispaly.o insert.o search.o files.o:buffer.h</div><div class="line">.PHONY:clean</div><div class="line">clean:</div><div class="line">  -rm edit $objects</div></pre></td></tr></table></figure>
</li>
</ul>
<p>是不是简洁得有点懵了，过于简单不太好理解。</p>
<ul>
<li><p>伪目标<br>上面的PHONY为什么要加在clean的前面？<br>假如当前目录下存在一个名叫clean的文件，那么执行make clean时，make发现clean文件存在，就不会执行make clean指令，进而不会执行删除任何文件。<br>怎么解决这个问题？这时PHONY就登场了。<br>.PHONY: clean就是声明clean是一个“伪目标”，告诉make执行clean目标时不要去检查当前目录下的clean文件是否存在，始终执行clean目标，即-rm edit $objects。<br>rm命令前加一个减号的意思是，忽略删除过程的一些文件不存在等情况。</p>
</li>
<li><p>Makefile中引用其他Makefile<br>在上面的例子中没有演示，Makefile包含其他Makefile的情形，其实Makefile可以像C语言中include其他头文件一样。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/course/embeded/lesson_10/" data-id="cj4l6e293000obhp5nh98u5zo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/tools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/course/embeded/tools/" class="article-date">
  <time datetime="2017-03-23T06:04:00.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/course/embeded/tools/">ARM Linux开发工具下载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ARM Linux交叉工具链下载<br><a href="http://www.veryarm.com/arm-none-linux-gnueabi-gcc" target="_blank" rel="external">http://www.veryarm.com/arm-none-linux-gnueabi-gcc</a></p>
<p>笔记<br>udev详解<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-udev/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-udev/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/course/embeded/tools/" data-id="cj4l6e29o001pbhp59v9vkfyu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/22/course/embeded/lesson_9/" class="article-date">
  <time datetime="2017-03-22T08:52:00.000Z" itemprop="datePublished">2017-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/22/course/embeded/lesson_9/">（9）gdb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="gdb简介"><a href="#gdb简介" class="headerlink" title="gdb简介"></a>gdb简介</h4><h4 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h4><h4 id="gdb进阶"><a href="#gdb进阶" class="headerlink" title="gdb进阶"></a>gdb进阶</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_9/link.jpg" alt="image"></p>
<h5 id="gdb简介-1"><a href="#gdb简介-1" class="headerlink" title="gdb简介"></a>gdb简介</h5><p>GDB, the GNU Project debugger, allows you to see what is going on ‘inside’ another program while it executes – or what another program was doing at the moment it crashed.</p>
<p>The program being debugged can be written in Ada, C, C++, Objective-C, Pascal (and many other languages). Those programs might be executing on the same machine as GDB (native) or on another machine (remote). GDB can run on most popular UNIX and Microsoft Windows variants.</p>
<p>GDB，GNU项目调试器，可以让您看到在执行另一个程序时发生了什么 - 或者其他程序在崩溃时正在做什么。</p>
<p>被调试的程序可以用Ada，C，C ++，Objective-C，Pascal（和许多其他语言）编写。 这些程序可能与GDB（本地）或另一台机器（远程）在同一台机器上执行。 GDB可以运行在大多数流行的UNIX和Microsoft Windows中。</p>
<h4 id="程序调试-1"><a href="#程序调试-1" class="headerlink" title="程序调试"></a>程序调试</h4><ul>
<li>gdb常用指令</li>
</ul>
<ol>
<li><p>检测gdb是否安装及版本号，若未安装gdb会提示“未找到命令”。fedora25默认已安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> $ gdb -v</div><div class="line">GNU gdb (GDB) Fedora 7.12-24.fc25</div><div class="line">Copyright (C) 2016 Free Software Foundation, Inc.</div></pre></td></tr></table></figure>
</li>
<li><p>编写test.c程序，内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int sum(int n)</div><div class="line">&#123;</div><div class="line">    int sum=0;</div><div class="line">    for(int i=0; i&lt;=n; i++)</div><div class="line">    &#123;</div><div class="line">	sum += i;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argv, char *args[])</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    long result=0;</div><div class="line">    for(i=1; i&lt;=10; i++)</div><div class="line">    &#123;</div><div class="line">        result += i;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;result[1-10]=%d\n&quot;,result);</div><div class="line">    printf(&quot;result[1-100]=%d\n&quot;,sum(100));</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译debug版本的testd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -o testd -g test.c</div></pre></td></tr></table></figure>
</li>
<li><p>gdb载入test，list或l查看源码，回车可继续浏览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  $ gdb testd</div><div class="line">  (gdb) list</div><div class="line">2</div><div class="line">3	int sum(int n)</div><div class="line">4	&#123;</div><div class="line">5	    int sum=0;</div><div class="line">6	    for(int i=0; i&lt;=n; i++)</div><div class="line">7	    &#123;</div><div class="line">8		sum += i;</div><div class="line">9	    &#125;</div><div class="line">10	    return sum;</div><div class="line">11	&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
<li><p>设置断点，break 行号，break 函数名，info break 查看断点信息，break也可简写成b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  (gdb) break 19</div><div class="line">Breakpoint 1 at 0x400544: file test.c, line 19.</div><div class="line">(gdb) break sum</div><div class="line">Breakpoint 2 at 0x4004fd: file test.c, line 5.</div><div class="line">(gdb) info break</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">2       breakpoint     keep y   0x00000000004004fd in sum at test.c:5</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
</li>
<li><p>清除断点，clear 行号，clear 函数名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  (gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">	breakpoint already hit 10 times</div><div class="line">2       breakpoint     keep y   0x00000000004004fd in sum at test.c:5</div><div class="line">	breakpoint already hit 1 time</div><div class="line">  第二个断点被清除</div><div class="line">(gdb) clear 5</div><div class="line">Deleted breakpoint 2</div><div class="line">(gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">	breakpoint already hit 10 times</div></pre></td></tr></table></figure>
</li>
<li><p>开始调试，输入run或r，停在第一个断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  (gdb) run</div><div class="line">Starting program: /home/highsung/dev/lesson_9/test</div><div class="line">Missing separate debuginfos, use: dnf debuginfo-install glibc-2.24-4.fc25.x86_64</div><div class="line"></div><div class="line">Breakpoint 1, main (argv=1, args=0x7fffffffe2b8) at test.c:19</div><div class="line">19	        result += i;</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
</li>
<li><p>单步执行，输入next或n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  (gdb) next</div><div class="line">17	    for(i=1; i&lt;=10; i++)</div><div class="line">(gdb) n</div><div class="line"></div><div class="line">Breakpoint 1, main (argv=1, args=0x7fffffffe2b8) at test.c:19</div><div class="line">19	        result += i;</div><div class="line">(gdb) n</div><div class="line">17	    for(i=1; i&lt;=10; i++)</div><div class="line">(gdb) n</div></pre></td></tr></table></figure>
</li>
<li><p>查看变量值，输入print或p</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  (gdb) print i</div><div class="line">$4 = 9</div><div class="line">(gdb) print result</div><div class="line">$5 = 45</div><div class="line">(gdb)</div><div class="line">$6 = 45</div><div class="line">(gdb) p i</div><div class="line">$7 = 9</div></pre></td></tr></table></figure>
</li>
<li><p>执行到下个断点，continue或c，没有断点程序结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  (gdb) continue</div><div class="line">Continuing.</div><div class="line">result[1-100]=5050</div><div class="line">[Inferior 1 (process 3674) exited normally]</div></pre></td></tr></table></figure>
</li>
<li><p>查看程序调用栈信息，当前执行到sum函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  (gdb) bt</div><div class="line">#0  sum (n=100) at test.c:6</div><div class="line">#1  0x0000000000400577 in main (argv=1, args=0x7fffffffe2b8) at test.c:22</div></pre></td></tr></table></figure>
</li>
<li><p>退出当前函数，finish</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  (gdb) finish</div><div class="line">Run till exit from #0  sum (n=100) at test.c:6</div><div class="line">0x0000000000400577 in main (argv=1, args=0x7fffffffe2b8) at test.c:22</div><div class="line">22	    printf(&quot;result[1-100]=%d\n&quot;,sum(100));</div><div class="line">Value returned is $10 = 5050</div><div class="line">(gdb) n</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="gdb进阶-1"><a href="#gdb进阶-1" class="headerlink" title="gdb进阶"></a>gdb进阶</h4><p>一般来说，调试程序时需要编译器带-g参数，如果没有-g，将看不到程序的函数名，变量名，所替代将是运行时的内存地址。<br>启动gdb的方法有以下几种：</p>
<ol>
<li>gdb &lt;program&gt;  带调试信息的program程序。</li>
<li>gdb &lt;program&gt; core core文件是program程序非法执行后生产的文件，可以用它还原程序崩溃现场。</li>
<li>gdb &lt;program&gt; &lt;PID&gt; 调试一个正常运行的进程，gdb会自动attach上去并调试它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sudo gdb /usr/local/nginx/sbin/nginx 3832</div><div class="line">(gdb) quit</div><div class="line">A debugging session is active.</div><div class="line"></div><div class="line">	Inferior 1 [process 3832] will be detached.</div><div class="line"></div><div class="line">Quit anyway? (y or n) y</div><div class="line">Detaching from program: /usr/local/nginx/sbin/nginx, process 3832</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在gdb准备执行run或r指令前，可以对一些环境参数进行设置：</p>
<ol>
<li><p>程序运行参数。<br>set args 指定运行时参数。如：set arg 1 2 3 4<br>show args 可以查看设置好的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  (gdb) set args 1 2 3 4</div><div class="line">(gdb) show args</div><div class="line">Argument list to give program being debugged when it is started is &quot;1 2 3 4&quot;.</div></pre></td></tr></table></figure>
</li>
<li><p>程序工作路径<br>path &lt;dir&gt; 添加程序的工作路径<br>show paths<br>当前目录被添加到了工作路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  (gdb) path .</div><div class="line">Executable and object file path: /home/highsung/dev/lesson_9:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/highsung/.local/bin:/home/highsung/bin</div><div class="line">(gdb) show paths</div><div class="line">Executable and object file path: /home/highsung/dev/lesson_9:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/highsung/.local/bin:/home/highsung/bin</div></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量<br>set environment varname=[value] 设置环境变量<br>show environment [varname] 查看环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  (gdb) set env XM1=111</div><div class="line">(gdb) show env XM1</div><div class="line">XM1 = 111</div><div class="line">(gdb) show env</div><div class="line">XDG_VTNR=1</div><div class="line">SSH_AGENT_PID=1183</div><div class="line">...</div><div class="line">LINES=24</div><div class="line">COLUMNS=80</div><div class="line">XM1=111</div></pre></td></tr></table></figure>
</li>
<li><p>程序的输入输出<br>info terminal 显示程序用到的终端模式，可以重定向到某个文件，如run &gt; outfile<br>也可用tty 命令指定输入输出的终端设备。如 tty /dev/ttyb</p>
</li>
</ol>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_9/20170323135654.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/22/course/embeded/lesson_9/" data-id="cj4l6e29n001nbhp5ey2156hm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/21/course/embeded/lesson_8/" class="article-date">
  <time datetime="2017-03-21T08:51:00.000Z" itemprop="datePublished">2017-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/21/course/embeded/lesson_8/">（8）gcc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="gcc简介"><a href="#gcc简介" class="headerlink" title="gcc简介"></a>gcc简介</h4><h4 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h4><h4 id="gcc编译object-c"><a href="#gcc编译object-c" class="headerlink" title="gcc编译object-c"></a>gcc编译object-c</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_8/link.jpg" alt="image"></p>
<h5 id="gcc简介-1"><a href="#gcc简介-1" class="headerlink" title="gcc简介"></a>gcc简介</h5><h6 id="GCC-the-GNU-Compiler-Collection"><a href="#GCC-the-GNU-Compiler-Collection" class="headerlink" title="GCC, the GNU Compiler Collection"></a><a href="http://gcc.gnu.org/" target="_blank" rel="external">GCC</a>, the GNU Compiler Collection</h6><p>The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Ada, and Go, as well as libraries for these languages (libstdc++,…). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user’s freedom.</p>
<p>GCC是GNU编译器集合。GNU编译器集合包括C，C ++，Objective-C，Fortran，Ada和Go的前端，以及这些语言的库（libstdc++，…）。 GCC最初是作为GNU操作系统的编译器编写的。 GNU系统被开发为100％免费的软件，它在尊重用户自由的意义上是免费的。</p>
<ul>
<li>gcc常用指令</li>
</ul>
<ol>
<li><p>检测gcc是否安装及版本号，若未安装gcc会提示“未找到命令”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gcc -v</div><div class="line">使用内建 specs。</div><div class="line">COLLECT_GCC=gcc</div><div class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/6.2.1/lto-wrapper</div><div class="line">目标：x86_64-redhat-linux</div><div class="line">配置为：../configure ...</div><div class="line">线程模型：posix</div><div class="line">gcc 版本 6.2.1 20160916 (Red Hat 6.2.1-2) (GCC)</div></pre></td></tr></table></figure>
</li>
<li><p>编写hello.c程序，内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argv, char *arg[])</div><div class="line">&#123;</div><div class="line">  printf(&quot;%s&quot;,&quot;hello gcc!\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译hello.c，生成a.out文件，执行之输出“hello gcc!”。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c</div><div class="line">$ ls</div><div class="line">a.out  hello.c</div><div class="line">$ ./a.out</div><div class="line">hello gcc!</div></pre></td></tr></table></figure>
</li>
<li><p>gcc常用编译选项</p>
</li>
</ol>
<ul>
<li><p>-o 指定编译生成的可执行程序名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c -o hello.exe</div><div class="line">$ ls</div><div class="line">a.out  hello.c  hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>-g 告诉编译器生成调试信息，如下，包含调试信息的hello.exe比a.out大一些。<br>用gdb调试程序时，程序必须包含调试信息才能调试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c -o hello.exe -g</div><div class="line">$ ls -al</div><div class="line">总用量 36</div><div class="line">-rwxrwxr-x. 1 highsung highsung  8528 3月  21 17:12 a.out</div><div class="line">-rw-rw-r--. 1 highsung highsung    97 3月  21 17:12 hello.c</div><div class="line">-rwxrwxr-x. 1 highsung highsung 11048 3月  21 17:29 hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>也可通过strip命令去除hello.exe中的调试信息，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ strip -g hello.exe</div><div class="line">$ ls -al</div><div class="line">总用量 36</div><div class="line">drwxrwxr-x. 2 highsung highsung 4096 3月  21 17:33 .</div><div class="line">drwxrwxr-x. 3 highsung highsung 4096 3月  21 17:08 ..</div><div class="line">-rwxrwxr-x. 1 highsung highsung 8528 3月  21 17:12 a.out</div><div class="line">-rw-rw-r--. 1 highsung highsung   97 3月  21 17:12 hello.c</div><div class="line">-rwxrwxr-x. 1 highsung highsung 8416 3月  21 17:33 hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>-static 以静态链接方式生成可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gcc -static hello.c -o a1</div><div class="line">/bin/ld: 找不到 -lc</div></pre></td></tr></table></figure>
<p>缺少静态包glibc-static，安装glibc-static后编译运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ dnf install -y glibc-static</div><div class="line">$ gcc -static hello.c -o a1</div><div class="line">$ ls -al</div><div class="line">-rwxrwxr-x. 1 highsung highsung   8480 3月  21 19:24 a</div><div class="line">-rwxrwxr-x. 1 highsung highsung 917632 3月  21 19:21 a1</div></pre></td></tr></table></figure>
<p>发现a1的大小比a大得多。因为a程序所依赖的程序指令全部打包到了a1中。<br>那么如何查看a所依赖的动态库？用ldd命令查看，如下。<br>显示a依赖3个动态库，动态库名字so.m.n结尾，so代表是动态库，m.n代表主次版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> $ ldd a</div><div class="line">linux-vdso.so.1 (0x00007ffc56d8e000)</div><div class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f09b1516000)</div><div class="line">/lib64/ld-linux-x86-64.so.2 (0x000055fcc140f000)</div><div class="line"> 这里提示a1不是一个动态执行文件</div><div class="line"> $ ldd a1</div><div class="line">not a dynamic executable</div><div class="line"> 用file命令查看，a1是静态链接方式。</div><div class="line"> $ file a1</div><div class="line"> a1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=686f47857cae85c959c39301843029ee1e98467e, not stripped</div></pre></td></tr></table></figure>
</li>
<li><p>-Idir 指定编译时，搜索头文件路径。<br>用 #include &lt;file.h&gt;时，gcc会在-I指定的目录中查找file.h，查找不到时，到缺省目录/usr/include/中查找。<br>用 #include “file.h”时，gcc会在当前目录下查找file.h，查找不到时，再按上面的顺序查找。</p>
</li>
<li><p>-include file.h，功能相当于在代码中使用#include &lt;file.h&gt;</p>
</li>
<li><p>-Ldir 指定链接时，搜索库的路径。默认库的路径在/usr/lib，/usr/lib64<br>例子如下，在当前目录下my/lib搜索库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -L./my/lib hello.c</div></pre></td></tr></table></figure>
</li>
<li><p>-llibrary 指定编译时候链接的库<br>例子如下，使用curses库链接程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -lcurses hello.c</div></pre></td></tr></table></figure>
</li>
<li><p>-O0 -O1 -O2 -O3，编译器优化的4个级别，-O0没有优化，-O1缺省优化，-O3最高级别优化。</p>
</li>
</ul>
<h5 id="程序编译过程-1"><a href="#程序编译过程-1" class="headerlink" title="程序编译过程"></a>程序编译过程</h5><p>gcc和g++执行编译工作的时候，总共需要4步：</p>
<ol>
<li>预处理，生成.i文件。-E选项激活</li>
<li>将预处理的文件转换成汇编语言，生成.s文件。-S选项激活</li>
<li>汇编指令转换成目标代码（机器代码），生成.o文件。-c选项激活</li>
<li>链接目标代码，生成可执行程序。-o选项激活<br>每一步的编译指令如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ gcc -E hello.c &gt;&gt; hello.i</div><div class="line">$ gcc -S hello.c</div><div class="line">$ gcc -c hello.c</div><div class="line">$ gcc -o hello hello.c</div><div class="line">$ ls -al</div><div class="line">-rwxrwxr-x. 1 highsung highsung   8480 3月  21 23:05 hello</div><div class="line">-rw-rw-r--. 1 highsung highsung     97 3月  21 19:07 hello.c</div><div class="line">-rw-rw-r--. 1 highsung highsung  16878 3月  21 23:02 hello.i</div><div class="line">-rw-rw-r--. 1 highsung highsung   1504 3月  21 23:02 hello.o</div><div class="line">-rw-rw-r--. 1 highsung highsung    501 3月  21 23:01 hello.s</div></pre></td></tr></table></figure>
</li>
</ol>
<p>预处理包含哪些处理？</p>
<ol>
<li>展开 #include 包含的头文件</li>
<li>处理条件编译指令，#if #ifndef #endif 等</li>
<li>替换 #define 定义的各种宏</li>
<li>处理编译指令，#pragma pack，#line 等</li>
</ol>
<h5 id="编译Objective-C"><a href="#编译Objective-C" class="headerlink" title="编译Objective-C"></a>编译Objective-C</h5><ol>
<li><p>安装<a href="http://www.oschina.net/p/gnustep-org/" target="_blank" rel="external">gnustep</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install gnustep*</div></pre></td></tr></table></figure>
</li>
<li><p>安装gcc-objc，gcc调用它来执行编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install gcc-objc</div></pre></td></tr></table></figure>
</li>
<li><p>编写一个Objective-C的Hello world文件hello.m。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Hello world, Object-C!&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译并运行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -o hello hello.m -lobjc -lgnustep-base -fconstant-string-class=NSConstantString</div><div class="line">$ ./hello</div><div class="line">...</div><div class="line">2017-03-23 23:11:36.295 helloworld[5405:5405] Hello world, Object-C!</div></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/21/course/embeded/lesson_8/" data-id="cj4l6e29m001lbhp54mz8sh85" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/20/course/embeded/lesson_7/" class="article-date">
  <time datetime="2017-03-20T05:37:00.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/20/course/embeded/lesson_7/">（7）Linux Shell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h4><h4 id="Shell配置和操作"><a href="#Shell配置和操作" class="headerlink" title="Shell配置和操作"></a>Shell配置和操作</h4><h4 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_7/link.jpg" alt="image"></p>
<p>Shell 是操作系统的外壳，是用户使用操作系统的命令接口；接受用户以命令行方式输入的命令(包括系统提供的内部命令、独立存在于某个目录下的程序），同时也能解释执行由Shell命令编写的Shell程序。</p>
<p>Shell、用户和内核的关系见下图：<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_7/shell.png" alt="image"></p>
<p>从上图中可以看出，Shell是用户和Linux系统之间交互的桥梁。黑客，有个性的程序员或工程师习惯在Shell中输入各种命令和配置指令。界面的各种炫，对他们来说都是out之物。</p>
<h6 id="1-Shell大概工作流程："><a href="#1-Shell大概工作流程：" class="headerlink" title="1. Shell大概工作流程："></a>1. Shell大概工作流程：</h6><ul>
<li>接受来自键盘的命令</li>
<li>检查命令的正确性</li>
<li>命令错误则给出报错信息</li>
<li>命令正确则使用相应的系统调用执行命令(产生进程)</li>
<li>命令执行完毕，给出命令执行的结果</li>
</ul>
<hr>
<p>执行过程：分为前台执行和后台执行<br>前台：Shell 要等待命令（进程）结束，才恢复自身的运行，即回到终端提示符。<br>后台：Shell 不必等待命令（进程）结束，就恢复自身的运行，即回到终端提示符。在执行时命令后&amp;，例：$ gcc m.c&amp;</p>
<h6 id="2-Shell分类："><a href="#2-Shell分类：" class="headerlink" title="2. Shell分类："></a>2. Shell分类：</h6><p>目前主要有下列版本的Shell：</p>
<ul>
<li>Bourne Shell：贝尔实验室开发</li>
<li>Bash：GNU的Bourne Again Shell，是GNU操作系统上的默认Shell。</li>
<li>Korn Shell：是对Bourne Shell扩展，大部分通它一样。</li>
<li>C Shell：SUN公司Shell的BSD版本。<br>查看当前Linux账号Shell版本，采用的GNU bash。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd</div><div class="line">highsung:x:1000:1000:highsung:/home/highsung:/bin/bash</div><div class="line">user2:x:1002:1001::/home/user2:/bin/bash</div><div class="line">user11:x:1001:1002::/home/user1:/bin/bash</div><div class="line">$ bash --version</div><div class="line">GNU bash，版本 4.3.43(1)-release (x86_64-redhat-linux-gnu)</div><div class="line">Copyright (C) 2013 Free Software Foundation, Inc.</div><div class="line">许可证 GPLv3+: GNU GPL 许可证第三版或者更新版本 &lt;http://gnu.org/licenses/gpl.html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="3-Shell相关配置"><a href="#3-Shell相关配置" class="headerlink" title="3. Shell相关配置"></a>3. Shell相关配置</h6><ul>
<li><p>Linux中每个用户都可指定他的Shell。<br>示例：useradd -s选项指定，无指定则用系统默认Shell程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -s /bin/bash</div></pre></td></tr></table></figure>
<p>highsung、user2、user11都是系统默认Shell程序：/bin/bash。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd</div><div class="line">highsung:x:1000:1000:highsung:/home/highsung:/bin/bash</div><div class="line">user2:x:1002:1001::/home/user2:/bin/bash</div><div class="line">user11:x:1001:1002::/home/user1:/bin/bash</div></pre></td></tr></table></figure>
</li>
<li><p>Shell的配置，Linux系统中每个用户都有各自的Shell工作环境，这样会导致命令提示，环境变量等的不一致。</p>
<ul>
<li>这些环境配置，集中在主目录下的.bash_profile，.bashrc，.bash_history文件。</li>
<li>.bashrc读取全局的/etc/bashrc的配置，.bahs_profile又读取.bashrc中的配置。</li>
<li>从上面的逻辑可以看出，可以把个性化的配置保存在.bahs_profile，全局配置保存在/etc/bashrc。</li>
<li>命令历史是Bash提供的一种功能，它保存了最近执行过的1000条命令，保存在.bash_history文件中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$HISTFILESIZE 定义.bash_history存放历史记录的个数</div><div class="line">$ echo $HISTFILESIZE</div><div class="line">1000</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h6 id="5-Shell基本操作"><a href="#5-Shell基本操作" class="headerlink" title="5. Shell基本操作:"></a>5. Shell基本操作:</h6><ul>
<li><p>Shell的启动和退出<br>用户在成功登录进入系统后，系统提供产生一个特定的Shell的拷贝(这是用户的第一个进程)负责解释执行用户的命令或Shell脚本。在系统提示符后用户键入的命令或Shell脚本名，来执行特定的命令或Shell脚本，用户希望中止命令或脚本的执行，可以用【ctrl+c】。<br>用户结束工作希望退出系统，可以按下面的键或命令:<br>【ctrl+d】<br>exit  命令<br>logout 命令</p>
</li>
<li><p>查看历史命令<br>历史命令就是上次在Shell中输入的命令。前面已经提到，历史命令保存在主目录下.bash_history。</p>
<ul>
<li><p>通过history命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ history</div><div class="line">  1  ls</div><div class="line">  2  rm /1</div><div class="line">  3  sudo rm /1</div><div class="line">  4  clear</div><div class="line">  5  ls</div><div class="line">  6  ls /</div><div class="line">  7  ls</div><div class="line">  8  ls / -al</div><div class="line">  9  clear</div><div class="line"> 10  ls / -al</div></pre></td></tr></table></figure>
</li>
<li><p>执行历史命令<br>!n:  执行编号为n的命令历史.<br>!-n: 执行命令历史中倒数第n个命令.<br>!!:  执行上一个历史命令.（在历史记录中不加入）<br>!字符串:  执行以“字符串”开头的历史命令.<br>!?字符串?: 执行包含“字符串”的历史命令.</p>
</li>
<li><p>命令历史的配置<br>给环境变量HISTFILE赋值，给出与.bash_history 不同的文件保存命令历史,例如： HISTFILE=newfile。<br>给环境变量HISTFILESIZE赋值，给出命令历史文件保存历史事件的个数,例如： HISTFILESIZE=1000。</p>
</li>
<li><p>别名，在Bash中可以使用alias命令为命令取一个别名，其中别名的内容可以是命令名、选项和参数。别名可以使用户键入命令时变得方便、简单。可以使用unalias命令来取消别名。</p>
<ul>
<li>定义别名格式：alias  [别名=“原命令”]<ul>
<li>原命令中包含命令名、选项和参数。</li>
<li>原命令中如有空格或特殊字符，应将其用单引号括起来。</li>
<li>等号=边不能有空格</li>
<li>不带任何参数的 alias  命令则显示已经定义的别名及其对应的命令。</li>
<li>本次登录建立的别名仅在本次登录有效，如果希望在每次登录都有效，应把alias 命令写入初始化脚本文件~/.bash_profile。</li>
</ul>
</li>
<li>例子：<br>$ alias  .. =’cd ..’<br>$ alias  cp =’cp -i’<br>$ alias  ll =’ls -l’</li>
<li>取消别名格式：unalias  别名<br>例：$unalias ll<br>$alias ll<br>ll:alias not found</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Shell特殊字符<ul>
<li>通配符<br>?:  表示任意的单个字符<br>*:  表示任意长的任意的字符串<br>[ ]:  表示匹配放在 [ ] 中的字符集中的单个字符</li>
<li>例子：<br>*   表示当前目录下的所有文件<br>f<em>  表示当前目录下以f 开头的文件<br>\</em>.txt  表示当前目录下以.txt结尾的文件<br>*sh*   表示当前目录下所有名字包含sh 的文件<br>x[ml]   表示当前目录下以xm 或xl 开头的所有文件</li>
</ul>
</li>
</ul>
<h6 id="6-Shell脚本"><a href="#6-Shell脚本" class="headerlink" title="6. Shell脚本:"></a>6. Shell脚本:</h6><p>用户可以将Linux的命令（文件，用户，网络等命令）以编程的方式组合起来提交给Shell，Shell负责解释执行这种程序设计语言。Linux把由这种程序设计语言构成的文件称为Shell Script，或Shell脚本。</p>
<ul>
<li><p>新建sh1.sh文件，内容“#!/bin/bash echo “hello bash””，增加可运行权限，再执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ vi sh1.sh</div><div class="line">#!/bin/bash</div><div class="line">echo &quot;hello bash&quot;</div><div class="line">$ chmod +x sh1.sh</div><div class="line">$ ./sh1.sh</div><div class="line">hello bash</div></pre></td></tr></table></figure>
<ul>
<li>第一行的#!后指定Shell类型</li>
<li>文中#代表注释符</li>
<li>Shell脚本文件需+x权限才可执行</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/20/course/embeded/lesson_7/" data-id="cj4l6e29h001hbhp58y4j4ye8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/20/course/embeded/lesson_6/" class="article-date">
  <time datetime="2017-03-20T02:24:00.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/20/course/embeded/lesson_6/">（6）Linux常用命令-进程和网络管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_5/install_soft.jpg" alt="image"></p>
<h5 id="进程管理主要涉及查看，查找当前运行进程ID，名称，CPU，内存等占用情况，杀死某些进程。"><a href="#进程管理主要涉及查看，查找当前运行进程ID，名称，CPU，内存等占用情况，杀死某些进程。" class="headerlink" title="进程管理主要涉及查看，查找当前运行进程ID，名称，CPU，内存等占用情况，杀死某些进程。"></a>进程管理主要涉及查看，查找当前运行进程ID，名称，CPU，内存等占用情况，杀死某些进程。</h5><h5 id="网络管理方面，查看系统网络适配器状态，启动，关闭网络适配器。ping某个IP是否被占用，修改主机IP地址和netmask。"><a href="#网络管理方面，查看系统网络适配器状态，启动，关闭网络适配器。ping某个IP是否被占用，修改主机IP地址和netmask。" class="headerlink" title="网络管理方面，查看系统网络适配器状态，启动，关闭网络适配器。ping某个IP是否被占用，修改主机IP地址和netmask。"></a>网络管理方面，查看系统网络适配器状态，启动，关闭网络适配器。ping某个IP是否被占用，修改主机IP地址和netmask。</h5><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h4><ul>
<li>查看当前系统进程运行情况，类似于Windows任务管理器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ top</div><div class="line">top - 11:02:20 up  3:04,  0 users,  load average: 0.00, 0.02, 0.03</div><div class="line">Tasks: 147 total,   2 running, 145 sleeping,   0 stopped,   0 zombie</div><div class="line">%Cpu(s):  2.0 us,  0.7 sy,  0.0 ni, 96.6 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem :   997172 total,   316164 free,   245008 used,   436000 buff/cache</div><div class="line">KiB Swap:  2256892 total,  2221596 free,    35296 used.   540444 avail Mem</div><div class="line"></div><div class="line">   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     </div><div class="line">   890 root      20   0  365924  42104  10380 S  1.0  4.2   0:30.62 Xorg        </div><div class="line">  1653 highsung  20   0  640080  23676  17356 S  1.0  2.4   0:11.89 lxterminal  </div><div class="line">  1518 highsung  20   0  388036  16792  12372 S  0.3  1.7   0:14.86 vmtoolsd    </div><div class="line">  1632 highsung  20   0  474348  19304  14828 S  0.3  1.9   0:17.55 clipit      </div><div class="line"> 22461 highsung  20   0  156640   3952   3476 R  0.3  0.4   0:00.03 top         </div><div class="line">     1 root      20   0  149252   7864   6348 S  0.0  0.8   0:02.01 systemd     </div><div class="line">     2 root      20   0       0      0      0 S  0.0  0.0   0:00.03 kthreadd    </div><div class="line">     3 root      20   0       0      0      0 S  0.0  0.0   0:04.10 ksoftirqd/0</div><div class="line">     5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:+</div><div class="line">     7 root      20   0       0      0      0 S  0.0  0.0   0:00.82 rcu_sched   </div><div class="line">     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh      </div><div class="line">     9 root      20   0       0      0      0 R  0.0  0.0   0:01.06 rcuos/0     </div><div class="line">    10 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcuob/0</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>top - 11:02:20</td>
<td>当前系统时间</td>
</tr>
<tr>
<td>up  3:04</td>
<td>系统开机时长，格式：小时:分钟</td>
</tr>
<tr>
<td>0 users</td>
<td>0个登录用户</td>
</tr>
<tr>
<td>load average: 0.00, 0.02, 0.03</td>
<td>系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
<tr>
<td>Tasks: 147 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>2 running</td>
<td>正在运行的进程数2个</td>
</tr>
<tr>
<td>145 sleeping</td>
<td>睡眠的进程数145个</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止的进程数0个</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数0个</td>
</tr>
<tr>
<td>%Cpu(s):  2.0 us</td>
<td>用户空间占用CPU百分比</td>
</tr>
<tr>
<td>0.7 sy</td>
<td>内核空间占用CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>96.6 id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>KiB Mem :   997172 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>316164 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>245008 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>436000 buff/cache</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td>KiB Swap:  2256892 total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>2221596 free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>35296 used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>540444 avail Mem</td>
<td>可用缓冲的交换区总量</td>
</tr>
</tbody>
</table>
<ul>
<li><p>查找某个进程是否运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">查找firefox是否启动，结果没有</div><div class="line">$ ps aux | grep firefox</div><div class="line">highsung  22559  0.0  0.0 119392   908 pts/0    S+   11:31   0:00 grep --color=auto firefox</div><div class="line">查找nginx是否运行，发现2个进程，1个master，1个worker</div><div class="line">$ ps aux | grep nginx</div><div class="line">root      21802  0.0  0.0  15932   360 ?        Ss   09:50   0:00 nginx: master process /usr/local/nginx/sbin/nginx</div><div class="line">nobody    21803  0.0  0.2  18444  2516 ?        S    09:50   0:00 nginx: worker process</div><div class="line">highsung  22561  0.0  0.0 119392   916 pts/0    S+   11:31   0:00 grep --color=auto nginx</div></pre></td></tr></table></figure>
</li>
<li><p>强制杀死某个进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">杀死nignx进程，9是kill信号，21802和21803是进程号</div><div class="line">$ sudo  kill -9 21802</div><div class="line">[sudo] highsung 的密码：</div><div class="line">$ sudo  kill -9 21803</div><div class="line">$ ps aux | grep nginx</div><div class="line">highsung  22603  0.0  0.0 119392   952 pts/0    S+   11:48   0:00 grep --color=auto nginx</div><div class="line">$</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-网络管理"><a href="#2-网络管理" class="headerlink" title="2. 网络管理"></a>2. 网络管理</h4><ul>
<li>查看网络适配器，发现有2个：ens33和lo。lo是环回地址，适合本机测试访问。外网访问通过ens33通信。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ ifconfig</div><div class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 192.168.124.139  netmask 255.255.255.0  broadcast 192.168.124.255</div><div class="line">        inet6 fe80::17b9:bbb6:331d:db1e  prefixlen 64  scopeid 0x20&lt;link&gt;</div><div class="line">        ether 00:0c:29:8e:58:5c  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 277372  bytes 331067727 (315.7 MiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 82261  bytes 5244773 (5.0 MiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line"></div><div class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</div><div class="line">        inet 127.0.0.1  netmask 255.0.0.0</div><div class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</div><div class="line">        loop  txqueuelen 1  (Local Loopback)</div><div class="line">        RX packets 1227  bytes 317260 (309.8 KiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 1227  bytes 317260 (309.8 KiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>flags=4163<up,broadcast,running,multicast></up,broadcast,running,multicast></td>
<td>UP（网卡开启状态）RUNNING（网卡的网线被接上）MULTICAST（支持组播）</td>
</tr>
<tr>
<td>mtu 1500</td>
<td>最大物理传输单元字节数</td>
</tr>
<tr>
<td>inet 192.168.124.139</td>
<td>IP地址</td>
</tr>
<tr>
<td>netmask 255.255.255.0</td>
<td>子网掩码</td>
</tr>
<tr>
<td>broadcast 192.168.124.255</td>
<td>广播地址</td>
</tr>
<tr>
<td>ether 00:0c:29:8e:58:5c</td>
<td>Mac地址</td>
</tr>
<tr>
<td>RX packets 277372  bytes 331067727 (315.7 MiB)</td>
<td>接收数据包字节数</td>
</tr>
<tr>
<td>RX errors 0  dropped 0  overruns 0  frame 0</td>
<td>接收错误包，丢包</td>
</tr>
<tr>
<td>TX packets 82261  bytes 5244773 (5.0 MiB)</td>
<td>发送数据包字节数</td>
</tr>
<tr>
<td>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</td>
<td>发送错误包，丢包</td>
</tr>
</tbody>
</table>
<ul>
<li>dropped，表示这个数据包已经进入到网卡的接收缓存fifo队列，并且开始被系统中断处理准备进行数据包拷贝（从网卡缓存fifo队列拷贝到系统内存），但由于此时的系统原因（比如内存不够等）导致这个数据包被丢掉，即这个数据包被Linux系统丢掉。</li>
<li>overruns，表示这个数据包还没有被进入到网卡的接收缓存fifo队列就被丢掉，因此此时网卡的fifo是满的。为什么fifo会是满的？因为系统繁忙，来不及响应网卡中断，导致网卡里的数据包没有及时的拷贝到系统内存，fifo是满的就导致后面的数据包进不来，即这个数据包被网卡硬件丢掉。所以，个人觉得遇到overruns非0，需要检测cpu负载与cpu中断情况。</li>
</ul>
<p>开关网络适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">关闭ens33</div><div class="line">$ sudo ifconfig ens33 down</div><div class="line">开启ens33</div><div class="line">$ sudo ifconfig ens33 up</div></pre></td></tr></table></figure></p>
<p>测试与其他主机是否可通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ping通一个外网域名，意味本机可以上网，听歌，下载文件等</div><div class="line">$ ping hao123.com</div><div class="line">PING hao123.com (180.149.132.19) 56(84) bytes of data.</div><div class="line">64 bytes from 180.149.132.19 (180.149.132.19): icmp_seq=1 ttl=128 time=75.7 ms</div><div class="line">64 bytes from 180.149.132.19 (180.149.132.19): icmp_seq=2 ttl=128 time=76.1 ms</div><div class="line">64 bytes from 180.149.132.19 (180.149.132.19): icmp_seq=3 ttl=128 time=76.6 ms</div><div class="line">ping通一个局域网地址，意味本机网络软硬件配置正常</div><div class="line">$ ping 192.168.1.1</div><div class="line">PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=2.00 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=3.14 ms</div><div class="line">ping不通局域网地址，意味另一台主机未开机，IP有误，防火墙开启等</div><div class="line">$ ping 192.168.1.111</div><div class="line">PING 192.168.1.111 (192.168.1.111) 56(84) bytes of data.</div><div class="line">From 192.168.1.104 icmp_seq=3 Destination Host Unreachable</div></pre></td></tr></table></figure></p>
<p>设置本机IP，子网掩码，广播IP，MTU，Mac:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifconfig ens33 192.168.124.239 netmask 255.255.255.0 broadcast 192.168.124.255</div><div class="line">ifconfig ens33 mtu 1400</div><div class="line">ifconfig ens33 hw ether 22:AA:BB:CC:DD:EE</div></pre></td></tr></table></figure></p>
<p>最后说下虚拟机访问网络的问题：</p>
<ol>
<li>当虚拟机需要访问外网，比如通过apt-get，dnf安装软件时：需要在虚拟机软件中把Linux网络适配器修改成“NAT模式”，系统自动获取IP即可。</li>
</ol>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_6/20170320124721.png" alt="image"></p>
<ol>
<li>当虚拟机需要局域网通信，比如访问开发板，挂载nfs系统时：需要在虚拟机软件中把Linux网络适配器修改成“桥接模式”，手动设置系统的局域网IP，设置前可以先ping下准备设置的IP是否已被占用。</li>
</ol>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_6/20170320124826.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/20/course/embeded/lesson_6/" data-id="cj4l6e29g001fbhp5lqlezi9q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/course/embeded/lesson_5/" class="article-date">
  <time datetime="2017-03-19T14:30:00.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/course/embeded/lesson_5/">（5）Linux常用命令-软件管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Linux系统分类"><a href="#Linux系统分类" class="headerlink" title="Linux系统分类"></a>Linux系统分类</h4><h4 id="软件包安装原理和命令"><a href="#软件包安装原理和命令" class="headerlink" title="软件包安装原理和命令"></a>软件包安装原理和命令</h4><h4 id="在线安装和手动下载源码安装"><a href="#在线安装和手动下载源码安装" class="headerlink" title="在线安装和手动下载源码安装"></a>在线安装和手动下载源码安装</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_5/install_soft.jpg" alt="image"></p>
<h5 id="大多数现代类-Unix-操作系统都提供了一个集中的软件包管理机制，以帮助用户搜索、安装和管理软件。而软件通常以「包」的形式存储在仓库「repository」中，对软件包的使用和管理被称为包管理。而-Linux-包的基本组成部分通常有：共享库、应用程序、服务和文档。"><a href="#大多数现代类-Unix-操作系统都提供了一个集中的软件包管理机制，以帮助用户搜索、安装和管理软件。而软件通常以「包」的形式存储在仓库「repository」中，对软件包的使用和管理被称为包管理。而-Linux-包的基本组成部分通常有：共享库、应用程序、服务和文档。" class="headerlink" title="大多数现代类 Unix 操作系统都提供了一个集中的软件包管理机制，以帮助用户搜索、安装和管理软件。而软件通常以「包」的形式存储在仓库「repository」中，对软件包的使用和管理被称为包管理。而 Linux 包的基本组成部分通常有：共享库、应用程序、服务和文档。"></a>大多数现代类 Unix 操作系统都提供了一个集中的软件包管理机制，以帮助用户搜索、安装和管理软件。而软件通常以「包」的形式存储在仓库「repository」中，对软件包的使用和管理被称为包管理。而 Linux 包的基本组成部分通常有：共享库、应用程序、服务和文档。</h5><h5 id="包管理通常不仅限于软件的一次性安装，还包括了对已安装软件包进行升级的工具。「包仓库」有助于确保代码已经在你使用的系统上进行了审核，并由软件开发者或包维护者进行管理。"><a href="#包管理通常不仅限于软件的一次性安装，还包括了对已安装软件包进行升级的工具。「包仓库」有助于确保代码已经在你使用的系统上进行了审核，并由软件开发者或包维护者进行管理。" class="headerlink" title="包管理通常不仅限于软件的一次性安装，还包括了对已安装软件包进行升级的工具。「包仓库」有助于确保代码已经在你使用的系统上进行了审核，并由软件开发者或包维护者进行管理。"></a>包管理通常不仅限于软件的一次性安装，还包括了对已安装软件包进行升级的工具。「包仓库」有助于确保代码已经在你使用的系统上进行了审核，并由软件开发者或包维护者进行管理。</h5><h5 id="本文将介绍常用-Linux-发行版对：搜索、安装和升级等包管理方面的基本方式和快速参考，可以帮助你快速了解不同-Linux-包管理基本操作与技巧。"><a href="#本文将介绍常用-Linux-发行版对：搜索、安装和升级等包管理方面的基本方式和快速参考，可以帮助你快速了解不同-Linux-包管理基本操作与技巧。" class="headerlink" title="本文将介绍常用 Linux 发行版对：搜索、安装和升级等包管理方面的基本方式和快速参考，可以帮助你快速了解不同 Linux 包管理基本操作与技巧。"></a>本文将介绍常用 Linux 发行版对：搜索、安装和升级等包管理方面的基本方式和快速参考，可以帮助你快速了解不同 Linux 包管理基本操作与技巧。</h5><h4 id="1-软件包管理介绍"><a href="#1-软件包管理介绍" class="headerlink" title="1. 软件包管理介绍"></a>1. 软件包管理介绍</h4><p>大多数流行的 Linux 发行版在包管理工具、方式和形式都大同小异，但却还是有平台差异。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>静态安装包格式</th>
<th>在线安装命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td>.deb</td>
<td>apt, apt-cache、apt-get、dpkg</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>.deb</td>
<td>apt、apt-cache、apt-get、dpkg</td>
</tr>
<tr>
<td>CentOS</td>
<td>.rpm</td>
<td>yum</td>
</tr>
<tr>
<td>Fedora</td>
<td>.rpm</td>
<td>yum、dnf</td>
</tr>
</tbody>
</table>
<p>Debian及其衍生产品如：Ubuntu、Linux Mint 和 Raspbian 的安装包格式为.deb文件，apt-get是最常见包操作命令，可搜索库、安装包及其依赖和管理升级。而要直接安装现成.deb包时需要使用dpkg命令。</p>
<p>CentOS、Fedora及Red Hat系列Linux使用RPM安装包文件，并使用yum命令管理包文件。</p>
<p>在最新的Fedora版本中，yum命令已被dnf取代进行包管理。</p>
<h4 id="2-更新本地包数据库列表"><a href="#2-更新本地包数据库列表" class="headerlink" title="2. 更新本地包数据库列表"></a>2. 更新本地包数据库列表</h4><p>大多数 Linux 都使用本地数据库来存储远程可用的包仓库列表，所以在安装或升级包之前最好更新一下这个数据库。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>sudo apt-get update</td>
</tr>
<tr>
<td>CentOS</td>
<td>yum check-update</td>
</tr>
<tr>
<td>Fedora</td>
<td>dnf check-update</td>
</tr>
</tbody>
</table>
<h4 id="3-升级已安装的包"><a href="#3-升级已安装的包" class="headerlink" title="3. 升级已安装的包"></a>3. 升级已安装的包</h4><p>在没有包管理方式时，要升级并保持 Linux 已装软件处在最新版本是一个巨大的工程，管理员和用户不得不手动跟踪上游软件版本变化及安全警告。在有了包管理系统之后，只需几条命令便可保持软件最新。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>sudo apt-get upgrade</td>
<td>仅升级已安装的软件包</td>
</tr>
<tr>
<td></td>
<td>sudo apt-get dist-upgrade</td>
<td>可添加或删除程序包，以满足新的依赖。</td>
</tr>
<tr>
<td>CentOS</td>
<td>sudo yum update</td>
<td></td>
</tr>
<tr>
<td>Fedora</td>
<td>sudo dnf upgrade</td>
</tr>
</tbody>
</table>
<h4 id="4-查找-搜索软件包"><a href="#4-查找-搜索软件包" class="headerlink" title="4. 查找/搜索软件包"></a>4. 查找/搜索软件包</h4><p>大多数 Linux 桌面版本都提供用户可搜索和安装软包的界面，这是找寻和安装软件的最佳方法。但对于追求效率和服务器管理员来说，使用命令行工具查找/搜索软件包才是正途。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>apt-cache search</td>
<td>搜索内容</td>
</tr>
<tr>
<td>CentOS</td>
<td>yum search</td>
<td>搜索内容</td>
</tr>
<tr>
<td></td>
<td>yum search all</td>
<td>搜索所有内容，包括包描述</td>
</tr>
<tr>
<td>Fedora</td>
<td>dnf search</td>
<td>搜索内容</td>
</tr>
<tr>
<td></td>
<td>dnf search all</td>
<td>搜索所有内容，包括包描述</td>
</tr>
</tbody>
</table>
<h4 id="5-查看某个软件包信息"><a href="#5-查看某个软件包信息" class="headerlink" title="5. 查看某个软件包信息"></a>5. 查看某个软件包信息</h4><p>在决定安装哪个包之前，我们往往都需要查看该软件包的详细说明。包的说明文件中通常包括：包名、版本号及依赖列表等元数据，可以使用如下命令来查看。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>apt-cache show 包名</td>
<td>显示有关软件包的本地缓存信息</td>
</tr>
<tr>
<td></td>
<td>dpkg -s 包名</td>
<td>显示包的当前安装状态</td>
</tr>
<tr>
<td>CentOS</td>
<td>yum info 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>yum deplist 包名</td>
<td>列出包的所有信息</td>
</tr>
<tr>
<td>Fedora</td>
<td>dnf info 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>dnf repoquery –requires 包名</td>
<td>列出包的所有信息</td>
</tr>
</tbody>
</table>
<h4 id="6-从软件仓库安装包"><a href="#6-从软件仓库安装包" class="headerlink" title="6. 从软件仓库安装包"></a>6. 从软件仓库安装包</h4><p>一旦我们知道某个软件包的名称之后，便可以使用如下命令从软件仓库安装包。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>sudo apt-get install 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sudo apt-get install 包1 包2 …</td>
<td>安装所有列出的包</td>
</tr>
<tr>
<td></td>
<td>sudo apt-get install -y 包名</td>
<td>无需提示直接安装</td>
</tr>
<tr>
<td>CentOS</td>
<td>sudo yum install 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sudo yum install 包1 包2 …</td>
<td>安装所有列出的包</td>
</tr>
<tr>
<td></td>
<td>sudo yum install -y 包名</td>
<td>无需提示直接安装</td>
</tr>
<tr>
<td>Fedora</td>
<td>sudo dnf install 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sudo dnf install 包1 包2 …</td>
<td>安装所有列出的包</td>
</tr>
<tr>
<td></td>
<td>sudo dnf install -y 包名</td>
<td>无需提示直接安装</td>
</tr>
</tbody>
</table>
<h4 id="7-从本地文件系统直接安装包"><a href="#7-从本地文件系统直接安装包" class="headerlink" title="7. 从本地文件系统直接安装包"></a>7. 从本地文件系统直接安装包</h4><p>很多时候，我们在进行测试或从某个地方直接拿到软件包之后需要从本地文件系统直接安装包。Debian 及衍生系统可以使用 dpkg 进行安装，CentOS 和 Fedora 系统使用 yum 和 dnf 命令进行安装。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>sudo dpkg -i 包名.deb</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sudo apt-get install -y gdebi&amp;&amp; sudo gdebi 包名.deb</td>
<td>使用gdebi检索缺少的依赖关系</td>
</tr>
<tr>
<td>CentOS</td>
<td>sudo yum install 包名.rpm</td>
<td></td>
</tr>
<tr>
<td>Fedora</td>
<td>sudo dnf install 包名.rpm</td>
</tr>
</tbody>
</table>
<h4 id="8-移除已安装的包"><a href="#8-移除已安装的包" class="headerlink" title="8. 移除已安装的包"></a>8. 移除已安装的包</h4><p>由于包管理器知道哪些文件是由哪个包提供的，所以在卸载不需要的软件包之后通常可以获得一个干净的系统。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian / Ubuntu</td>
<td>sudo apt-get remove 包名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sudo apt-get autoremove</td>
<td>自动移除不需要的包</td>
</tr>
<tr>
<td>CentOS</td>
<td>sudo yum remove 包名</td>
<td></td>
</tr>
<tr>
<td>Fedora</td>
<td>sudo dnf erase 包名</td>
</tr>
</tbody>
</table>
<h4 id="9-动手安装qtcreator，firefox"><a href="#9-动手安装qtcreator，firefox" class="headerlink" title="9. 动手安装qtcreator，firefox"></a>9. 动手安装qtcreator，firefox</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install -y qtcreator</div><div class="line">$ sudo dnf install -y firefox</div></pre></td></tr></table></figure>
<h4 id="10-编译源码方式，安装nginx"><a href="#10-编译源码方式，安装nginx" class="headerlink" title="10. 编译源码方式，安装nginx"></a>10. 编译源码方式，安装nginx</h4><ul>
<li><a href="http://nginx.org/download/nginx-1.11.10.tar.gz" target="_blank" rel="external">点击</a>下载nginx源码</li>
<li><p>解压源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf nginx-1.11.10.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>配置并编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd nginx-1.11.10</div><div class="line">$ ./configure --without-http_rewrite_module --without-http_gzip_module</div><div class="line">$ make</div></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>运行nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo /usr/local/nginx/sbin/nginx</div></pre></td></tr></table></figure>
</li>
<li><p>打开firefox，访问<a href="http://127.0.0.1" target="_blank" rel="external">http://127.0.0.1</a><br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_5/20170319234932.png" alt="image"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/course/embeded/lesson_5/" data-id="cj4l6e29f001bbhp5ter90cki" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/course/embeded/lesson_4/" class="article-date">
  <time datetime="2017-03-19T01:45:00.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/course/embeded/lesson_4/">（4）Linux常用命令-账号管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="修改账号密码"><a href="#修改账号密码" class="headerlink" title="修改账号密码"></a>修改账号密码</h4><h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_4/user.jpg" alt="image"></p>
<h5 id="Linux和Windows最大不同之处，就是从账号登录开始。Windows下大多数用户习惯开机即用，跳过登录窗口。而Linux环境则强制用户选择账号密码登录。虽然Linux整体账号设计比Windows更严谨，但增强我们的安全意识更重要。"><a href="#Linux和Windows最大不同之处，就是从账号登录开始。Windows下大多数用户习惯开机即用，跳过登录窗口。而Linux环境则强制用户选择账号密码登录。虽然Linux整体账号设计比Windows更严谨，但增强我们的安全意识更重要。" class="headerlink" title="Linux和Windows最大不同之处，就是从账号登录开始。Windows下大多数用户习惯开机即用，跳过登录窗口。而Linux环境则强制用户选择账号密码登录。虽然Linux整体账号设计比Windows更严谨，但增强我们的安全意识更重要。"></a>Linux和Windows最大不同之处，就是从账号登录开始。Windows下大多数用户习惯开机即用，跳过登录窗口。而Linux环境则强制用户选择账号密码登录。虽然Linux整体账号设计比Windows更严谨，但增强我们的安全意识更重要。</h5><h5 id="对于初学者，习惯拿root账号登录和后续操作，须不知会埋下诸多雷。因为root权限下访问和生成的一些文件，切换成其他账号登录后，很可能无对等权限访问。也有人会说，这个Linux系统就我一人使用，拿root登录可不可以，答案当然是可以。但你要清楚root权限下操作对系统所带来的影响。root账号拥有系统最高权限，所谓权利越大，责任越大。"><a href="#对于初学者，习惯拿root账号登录和后续操作，须不知会埋下诸多雷。因为root权限下访问和生成的一些文件，切换成其他账号登录后，很可能无对等权限访问。也有人会说，这个Linux系统就我一人使用，拿root登录可不可以，答案当然是可以。但你要清楚root权限下操作对系统所带来的影响。root账号拥有系统最高权限，所谓权利越大，责任越大。" class="headerlink" title="对于初学者，习惯拿root账号登录和后续操作，须不知会埋下诸多雷。因为root权限下访问和生成的一些文件，切换成其他账号登录后，很可能无对等权限访问。也有人会说，这个Linux系统就我一人使用，拿root登录可不可以，答案当然是可以。但你要清楚root权限下操作对系统所带来的影响。root账号拥有系统最高权限，所谓权利越大，责任越大。"></a>对于初学者，习惯拿root账号登录和后续操作，须不知会埋下诸多雷。因为root权限下访问和生成的一些文件，切换成其他账号登录后，很可能无对等权限访问。也有人会说，这个Linux系统就我一人使用，拿root登录可不可以，答案当然是可以。但你要清楚root权限下操作对系统所带来的影响。root账号拥有系统最高权限，所谓权利越大，责任越大。</h5><h5 id="建议玩法：创建一个非root账号登录，需要更高权限执行命令时，可以在命令前加sudo，sudo命令的含义是以root权限执行。"><a href="#建议玩法：创建一个非root账号登录，需要更高权限执行命令时，可以在命令前加sudo，sudo命令的含义是以root权限执行。" class="headerlink" title="建议玩法：创建一个非root账号登录，需要更高权限执行命令时，可以在命令前加sudo，sudo命令的含义是以root权限执行。"></a>建议玩法：创建一个非root账号登录，需要更高权限执行命令时，可以在命令前加sudo，sudo命令的含义是以root权限执行。</h5><h4 id="1-修改账号密码"><a href="#1-修改账号密码" class="headerlink" title="1. 修改账号密码"></a>1. 修改账号密码</h4><p>  查看当前账号<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">显示当前账户</div><div class="line">$ whoami   </div><div class="line">highsung</div><div class="line">切换到root</div><div class="line">$ su root  </div><div class="line">密码：</div><div class="line"># whoami</div><div class="line">root</div><div class="line"># su highsung</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>  修改密码，fedora25中密码必须是8个及以上字符，且不能全是数字。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ passwd</div><div class="line">更改用户 highsung 的密码 。</div><div class="line">为 highsung 更改 STRESS 密码。</div><div class="line">Current password:</div><div class="line">新的 密码：</div><div class="line">重新输入新的 密码：</div><div class="line">passwd：所有的身份验证令牌已经成功更新。</div></pre></td></tr></table></figure></p>
<p>  当然也可在root账号下，修改其他账号密码。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ su root</div><div class="line">密码：</div><div class="line"># passwd highsung</div><div class="line">更改用户 highsung 的密码 。</div><div class="line">新的 密码：</div><div class="line">重新输入新的 密码：</div><div class="line">passwd：所有的身份验证令牌已经成功更新。</div></pre></td></tr></table></figure></p>
<h4 id="2-用户组管理"><a href="#2-用户组管理" class="headerlink" title="2. 用户组管理"></a>2. 用户组管理</h4><p>在操作用户组前，我们先来看看/etc/passwd，/etc/shadow，/etc/group这三个文件内容。<br>/etc/passwd中每一行记录着一个用户信息，每行记录被冒号(:)分隔为7个字段，其格式和具体含义如下：<br>用户名:口令:用户标识ID:组标识ID:注释性描述:主目录:登录Shell。<br>下面的口令字段都是x，代表这项没有值。因为所有用户的口令信息都存放在/etc/shadow中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo cat /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">...</div><div class="line">highsung:x:1000:1000:highsung:/home/highsung:/bin/bash</div></pre></td></tr></table></figure></p>
<p>/etc/shadow中每一行记录着一个用户口令信息，每行记录被冒号(:)分隔为9个字段，其格式和具体含义如下：<br>用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志<br>下面的加密口令为*，代表这项没有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo cat /etc/shadow</div><div class="line">root:$6$q4pnE9vO4cv6ayga$ywkgbdr8YZQrjXFV0nZ.0HJE.zPrXAgzWErsPYZo67gyXvXRSbxqZAqWvnD1SGBOV/CJ2RSxgjGtXaP6KaYxN/::0:99999:7:::</div><div class="line">bin:*:17004:0:99999:7:::</div><div class="line">daemon:*:17004:0:99999:7:::</div><div class="line">...</div><div class="line">highsung:$6$Qo5xOJ5rqfOEjSb6$Ot1VLazAFvq1c0WQ.Ms1QhJFqgoG0P36FXsrygGfdcJvGDZTAk8vGtOA8wWLmKX5bNDTFCFSGQOKnmcLn5fcn.:17244:0:99999:7:::</div></pre></td></tr></table></figure></p>
<p>/etc/group中每一行记录着一个用户组信息，每行记录被冒号(:)分隔为4个字段，其格式和具体含义如下：<br>组名:口令:组标识ID:组内用户列表<br>下面的口令为x，代表这项没有值。<br>wheel是管理员组，组员有highsung。因为安装fedora25时，highsung设置成了管理员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ sudo cat /etc/group</div><div class="line">root:x:0:</div><div class="line">bin:x:1:</div><div class="line">daemon:x:2:</div><div class="line">sys:x:3:</div><div class="line">adm:x:4:</div><div class="line">tty:x:5:</div><div class="line">disk:x:6:</div><div class="line">lp:x:7:</div><div class="line">mem:x:8:</div><div class="line">kmem:x:9:</div><div class="line">wheel:x:10:highsung</div><div class="line">...</div><div class="line">highsung:x:1000:</div></pre></td></tr></table></figure></p>
<p>清楚了文件/etc/passwd，/etc/shadow，/etc/group的内容含义，下面先来操作下用户组。</p>
<ul>
<li><p>创建用户组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">创建mygroup1组</div><div class="line">$ sudo groupadd mygroup1      </div><div class="line">创建mygroup2组，同时指定组ID</div><div class="line">$ sudo groupadd -g 1010 mygroup2  </div><div class="line">创建mygroup3组</div><div class="line">$ sudo groupadd mygroup3  </div><div class="line">$ cat /etc/group</div><div class="line">...</div><div class="line">highsung:x:1000:</div><div class="line">组ID是在最后的highsung组ID上加1</div><div class="line">mygroup1:x:1001:  </div><div class="line">组ID强制指定1010</div><div class="line">mygroup2:x:1010:</div><div class="line">组ID是在最后的mygroup2组ID上加1</div><div class="line">mygroup3:x:1011:</div></pre></td></tr></table></figure>
</li>
<li><p>修改用户组<br>根据组名来修改，把mygroup3组的组名改成mygroup31，组ID改成1031</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo groupmod -g 1031 -n mygroup31 mygroup3</div><div class="line">$ cat /etc/group</div><div class="line">...</div><div class="line">highsung:x:1000:</div><div class="line">mygroup1:x:1001:</div><div class="line">mygroup2:x:1010:</div><div class="line">mygroup31:x:1031:</div></pre></td></tr></table></figure>
</li>
<li><p>删除用户组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo groupdel mygroup31</div><div class="line">$ sudo groupdel mygroup2</div><div class="line">$ cat /etc/group</div><div class="line">...</div><div class="line">highsung:x:1000:</div><div class="line">mygroup1:x:1001:</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h4><ul>
<li><p>创建用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">创建user1</div><div class="line">$ sudo useradd user1  </div><div class="line">设置user1密码</div><div class="line">$ sudo passwd user1    </div><div class="line">查看用户组，发现存在以user1命名的用户组</div><div class="line">$ cat /etc/group</div><div class="line">...  </div><div class="line">highsung:x:1000:</div><div class="line">mygroup1:x:1001:</div><div class="line">user1:x:1002:</div><div class="line">创建user2，并指定到mygroup1组，附加到wheel组</div><div class="line">$ sudo useradd user2 -g mygroup1 -G wheel</div><div class="line">$ cat /etc/group</div><div class="line">...</div><div class="line">user2也是管理员权限</div><div class="line">wheel:x:10:highsung,user2</div><div class="line">highsung:x:1000:</div><div class="line">mygroup1:x:1001:</div><div class="line">user1:x:1002:</div></pre></td></tr></table></figure>
</li>
<li><p>修改用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">user1添加到wheel组</div><div class="line">$ sudo usermod -G wheel user1</div><div class="line">$ cat /etc/group</div><div class="line">wheel:x:10:highsung,user2,user1</div><div class="line">user1名字改为user11</div><div class="line">$ sudo usermod -l user11 user1</div><div class="line">$ cat /etc/group</div><div class="line">wheel:x:10:highsung,user2,user11</div><div class="line">usr11的主目录还是/home/user1</div><div class="line">$ cat /etc/passwd</div><div class="line">user11:x:1001:1002::/home/user1:/bin/bash</div></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">删除3个文件中user2的记录，保留home目录</div><div class="line">$ sudo userdel user2</div><div class="line">删除3个文件中user2的记录，删除home目录</div><div class="line">$ sudo userdel -r user1</div></pre></td></tr></table></figure>
</li>
</ul>
<p>留个问题：root账号密码忘了怎么办？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/course/embeded/lesson_4/" data-id="cj4l6e29i001jbhp5jt6n8h2g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-studio/">android studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-git/">hexo git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opensource/">opensource</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springmvc/">springmvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大学生实训/">大学生实训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/校园采风/">校园采风</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/android-studio/" style="font-size: 10px;">android studio</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/hexo-git/" style="font-size: 10px;">hexo git</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/opensource/" style="font-size: 10px;">opensource</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springmvc/" style="font-size: 10px;">springmvc</a> <a href="/tags/大学生实训/" style="font-size: 10px;">大学生实训</a> <a href="/tags/嵌入式开发/" style="font-size: 20px;">嵌入式开发</a> <a href="/tags/校园采风/" style="font-size: 10px;">校园采风</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/01/course/android/opensource/">android开源项目</a>
          </li>
        
          <li>
            <a href="/2017/07/01/course/android/tip/">android studio 环境配置</a>
          </li>
        
          <li>
            <a href="/2017/06/29/course/javaee/tip/">javaee 环境配置</a>
          </li>
        
          <li>
            <a href="/2017/05/03/course/embeded/lesson_18/">（18）qt信号槽</a>
          </li>
        
          <li>
            <a href="/2017/04/28/course/embeded/lesson_17/">（17）视频预览和采集图片</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 HighSung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>