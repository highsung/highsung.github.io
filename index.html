<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HighSung</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="start here~~">
<meta property="og:type" content="website">
<meta property="og:title" content="HighSung">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HighSung">
<meta property="og:description" content="start here~~">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HighSung">
<meta name="twitter:description" content="start here~~">
  
    <link rel="alternate" href="/atom.xml" title="HighSung" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HighSung</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Make progress bit by bit every day</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-course/embeded/lesson_15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/27/course/embeded/lesson_15/" class="article-date">
  <time datetime="2017-04-27T08:51:00.000Z" itemprop="datePublished">2017-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/27/course/embeded/lesson_15/">（15）Uboot实验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Uboot启动源码分布"><a href="#Uboot启动源码分布" class="headerlink" title="Uboot启动源码分布"></a>Uboot启动源码分布</h5><p>启动顺序定义：uboot1.1.6\board\samsung\smdk6410\u-boot.lds</p>
<ol>
<li>复位启动开始的地方<br>uboot1.1.6/cpu/s3c64xx/Start.S<br>|——-&gt; reset:<pre><code>|--------&gt; start_armboot
</code></pre></li>
</ol>
<ol>
<li>配置板卡的各种硬件信息。<br>board.c<br>|——-&gt; start_armboot<pre><code>|-----------&gt; init_fnc_t **init_fnc_ptr;----|---&gt; cpu_init
|-----------&gt; main_loop                     |---&gt; board_init
                                            |---&gt; interrupt_init
                                            |---&gt; env_init
                                            |---&gt; init_baudrate
                                            |---&gt; serial_init
                                            |---&gt; console_init_f
                                            |---&gt; display_banner
                                            |---&gt; print_cpuinfo
                                            |---&gt; checkboard
                                            |---&gt; dram_init
                                            |---&gt; display_dram_config
</code></pre></li>
</ol>
<h5 id="Uboot实验"><a href="#Uboot实验" class="headerlink" title="Uboot实验"></a>Uboot实验</h5><p>实验一：修改Uboot启动时的打印Logo</p>
<hr>
<p><strong>    u-boot 1.1.6                       </strong></p>
<p><strong>    Updated for OK6410  TE6410 Board   </strong></p>
<p><strong>    Version (2012-09-23)               </strong></p>
<p><strong>    Builder: Lao Embedded              </strong></p>
<p><strong>    Web: <a href="http://www.hwadee.com" target="_blank" rel="external">http://www.hwadee.com</a>         </strong></p>
<hr>
<p>实验二：添加自定义命令：</p>
<ol>
<li><p>在对应的开发板配置文件中，添加相应命令的宏定义<br>比如在uboot/include/configs/smdk6410.h<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ul>
<li>Command definition<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>#define CONFIG_COMMANDS \<pre><code>(CONFIG_CMD_DFL    | \
CFG_CMD_CACHE    | \
CFG_CMD_USB    | \
CFG_CMD_REGINFO    | \
CFG_CMD_LOADS    | \
CFG_CMD_LOADB    | \
CFG_CMD_ENV    | \
CFG_CMD_MYTEST
</code></pre></li>
</ul>
</li>
<li><p>在uboot/common/目录下，建立相应的命令执行文件，如cmd_mytest.c，注意命名的规范，必须是cmd_mytest.c才行。<br>#include <common.h><br>#include <command.h><br>#ifdef CFG_CMD_MYTEST</command.h></common.h></p>
</li>
</ol>
<p>int do_mytest()<br>{<br>    printf(“this is my test command. it is a new command.\n”);<br>    return 0;<br>}</p>
<p>U_BOOT_CMD(mytest, 1, 0, do_mytest, “mytest  - just a demo that add new command\n”, “usage: mytest\n”);</p>
<p>#endif</p>
<ol>
<li><p>在uboot/comman/Makefile文件中，加入生成相应的cmd_mytest.o文件才可以</p>
</li>
<li><p>编译烧写uboot，验证修改成果<br>敲入help，显示的结果</p>
</li>
</ol>
<p>#help<br>mytest  - just a demo that add new command</p>
<p>SMDK6410 # mytest</p>
<p>this is my test command. it is a new command.</p>
<p>实验三：修改环境参数<br>// 启动参数</p>
<p>#define CONFIG_BOOTARGS     “root=/dev/mtdblock2 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200”<br>// 网卡MAC地址</p>
<p>#define CONFIG_ETHADDR        00:40:5c:26:0a:5b<br>// 网卡IP，掩码，网关，nfs服务器IP</p>
<p>#define CONFIG_IPADDR        10.10.141.234</p>
<p>#define CONFIG_NETMASK      255.255.255.0</p>
<p>#define CONFIG_GATEWAYIP    10.10.141.2</p>
<p>#define CONFIG_SERVERIP        10.10.141.117<br>// 启动参数: 从nandflash的0x200000位置读取0x500000（5M空间）到0xc00080000，然后从0xc0008000开始执行</p>
<p>#define CONFIG_BOOTCOMMAND    “nand read 0xc0008000 0x200000 0x500000;bootm 0xc0008000”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/27/course/embeded/lesson_15/" data-id="cj1zsm1qp000yrkufxlzfg5en" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_14" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/27/course/embeded/lesson_14/" class="article-date">
  <time datetime="2017-04-27T02:20:00.000Z" itemprop="datePublished">2017-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/27/course/embeded/lesson_14/">（14）Uboot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Uboot介绍"><a href="#Uboot介绍" class="headerlink" title="Uboot介绍"></a>Uboot介绍</h5><p>Uboot是德国DENX小组的开发用于多种嵌入式CPU的bootloader程序, UBoot不仅仅支持嵌入式Linux系统的引导，当前，它还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS嵌入式操作系统。UBoot除了支持PowerPC系列的处理器外，还能支持MIPS、 x86、ARM、NIOS、XScale等诸多常用系列的处理器。</p>
<h5 id="uboot的体系结构"><a href="#uboot的体系结构" class="headerlink" title="uboot的体系结构"></a>uboot的体系结构</h5><p>目录树</p>
<p> |–board<br> |–common<br> |–cpu<br> |–disk<br> |–doc<br> |–drivers<br> |–dtt<br> |–examples<br> |–fs<br> |–include<br> |–lib_arm<br> |–lib_generic<br> |–net<br> |–post<br> |–rtc<br> |–tools</p>
<ol>
<li>board：和一些已有开发板有关的文件. 每一个开发板都以一个子目录出现在当前目录中，比如说: uboot1.1.6\board\samsung\smdk6410子目录中存放与我们开发板相关的配置文件。</li>
<li>common：实现uboot命令行下支持的命令，每一条命令都对应一个文件。例如bootm命令对应就是cmd_bootm.c。</li>
<li>cpu：与特定CPU架构相关目录，每一款Uboot下支持的CPU在该目录下对应一个子目录，比如有子目录uboot1.1.6\cpu\s3c64xx就是我们开发板上使用的cpu架构目录。</li>
<li>disk：对磁盘的支持。</li>
<li>doc：文档目录。Uboot有非常完善的文档，推荐大家参考阅读。</li>
<li>drivers：Uboot支持的设备驱动程序都放在该目录，比如各种网卡、支持CFI的Flash、串口和USB等。</li>
<li>fs: 支持的文件系统，Uboot现在支持cramfs、fat、fdos、jffs2和registerfs。</li>
<li>include：Uboot使用的头文件，还有对各种硬件平台支持的汇编文件，系统的配置文件和对文件系统支持的文件。该目录下configs目录有与开 发板相关的配置头文件，如leopard2a.h。该目录下的asm目录有与CPU体系结构相关的头文件，asm对应的是asmarm.</li>
<li>lib_xxxx: 与体系结构相关的库文件。如与ARM相关的库放在lib_arm中。</li>
<li>net：与网络协议栈相关的代码，BOOTP协议、TFTP协议、RARP协议和NFS文件系统的实现。</li>
<li>tools：生成Uboot的工具，如：mkimage, crc等等。</li>
</ol>
<h5 id="uboot的运行过程分析"><a href="#uboot的运行过程分析" class="headerlink" title="uboot的运行过程分析"></a>uboot的运行过程分析</h5><p>大多数bootloader都分为阶段1(stage1)和阶段2(stage2)两大部分，uboot也不例外。依赖于CPU体系结构的代码（如CPU初 始化代码等）通常都放在阶段1中且通常用汇编语言实现，而阶段2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</p>
<p> U - Boot 编译后的代码定义一般不超过100kB ,并且这100 kB 又分成两个阶段来执行. 第一阶段的代码在start.s 中定义,大小不超过10kB ,它包括从系统上电后在0x00000000 地址开始执行的部分. 这部分代码运行在Flash 中,它包括对arm9的一些寄存器的初始化和将U - Boot 的第二阶段代码从Flash 拷贝到SDRAM 中. 除去第一阶段的代码,剩下的部分都是第二阶段的代码. 第二阶段的起始地址是在第一阶段代码中指定的,被复制到SDRAM后,就从第一阶段跳到这个入口地址开始执行剩余部分代码. 第二阶段主要是进行一些BSS 段设置,堆栈的初始化等工作,最后会跳转到main -loop 函数中,接受命令并进行命令处理. 图1 给出了U - Boot 的详细的运行过程包括对内核的设置、装载及调用过程。系统复位进入u-boot stage l的入口点。</p>
<p>硬件设备的初始化<br>为加载uboot stage 2准备ram空间<br>设置好堆栈<br>跳转到stage 2的C入口点<br>初始化本阶段要用到的设备<br>检查内存映射<br>将kernel映像和文件映像从flash中读到ram中<br>为内核设定启动参数<br>调用内核</p>
<p>运行代码分析</p>
<p>stage 1<br>uboot的stage1代码通常放在start.s文件中，它用汇编语言写成，其主要代码包括定义入口，设置异常向量，设置cpu的模式和频率，配置内 存区控制寄存器，安装uboot的栈空间，关闭看门狗等。由于本人对ram的汇编不太熟悉，所以这一部分不作具体分析。</p>
<p>stage 2<br>lib_arm/board.c中的start armboot是C语言开始的函数，也是整个启动代码中C语言的主函数，同时还是整个uboot(armboot）的主函数，该函数主要完成如下操作：<br>  调用一系列初始化函数</p>
<ol>
<li><p>指定初始函数表：<br>init_fnc_t <em>init_sequence[] = {<br>cpu_init, /</em> cpu的基本设置 <em>/<br>board_init, /</em> 开发板的基本初始化 <em>/<br>interrupt_init, /</em> 初始化中断 <em>/<br>env_init, /</em> 初始化环境变量 <em>/<br>init_baudrate, /</em> 初始化波特率 <em>/<br>serial_init, /</em> 串口通讯初始化 <em>/<br>console_init_f, /</em> 控制台初始化第一阶段 <em>/<br>display_banner, /</em> 通知代码已经运行到该处 <em>/<br>dram_init, /</em> 配制可用的内存区 */<br>display_dram_config,<br>#if defined(CONFIG_VCMA9) || defined (CONFIG_CMC_PU2)<br>checkboard,<br>#endif<br>NULL,<br>};</p>
<p>执行初始化函数的代码如下：<br>for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {</p>
<pre><code>if ((*init_fnc_ptr)() != 0) {
  hang ();
}
</code></pre><p>}</p>
</li>
<li><p>配置可用的Flash区<br>flash_init ()</p>
</li>
<li><p>初始化内存分配函数<br>mem_malloc_init()</p>
</li>
<li><p>nand flash初始化<br>#if (CONFIG_COMMANDS &amp; CFG_CMD_NAND)<br>puts (“NAND:”);<br>nand_init();        /<em> go init the NAND </em>/<br>#endif</p>
</li>
<li><p>初始化环境变量<br>env_relocate ();</p>
</li>
<li><p>外围设备初始化<br>devices_init()</p>
</li>
<li><p>I2C总线初始化<br>i2c_init();</p>
</li>
<li><p>LCD初始化<br>drv_lcd_init();</p>
</li>
<li><p>VIDEO初始化<br>drv_video_init();</p>
</li>
<li><p>键盘初始化<br>drv_keyboard_init();</p>
</li>
<li><p>系统初始化<br>drv_system_init();</p>
</li>
</ol>
<p>   初始化网络设备</p>
<pre><code>初始化相关网络设备，填写IP、MAC地址等。

1. 设置IP地址
gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr (&quot;ipaddr&quot;);

2. 设置mac地址
{
       int i;
       ulong reg;
       char *s, *e;
       uchar tmp[64];

       i = getenv_r ((uchar*)(&quot;ethaddr&quot;), tmp, sizeof (tmp));
       s = (i &gt; 0) ? (char*)tmp : NULL;

       for (reg = 0; reg &lt; 6; ++reg) {
         gd-&gt;bd-&gt;bi_enetaddr[reg] = s ? simple_strtoul (s, &amp;e, 16) : 0;
         if (s)
            s = (*e) ? e + 1 : e;
       }
}


进入主UBOOT 命令行

 进入命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作。
 for (;;) {
        main_loop ();
 }}

3、uboot的移植和测试

 3.1 移植的过程

 ① 在宿主机上建立交叉编译开发环境
 ② 修改cpu／arm926ejst目录中的文件内容，
 主要包含cpu．C，start．S，interrupts．C以及seria1．C，speed．C等文件
 ③ 在board目录下创建自己的目标板(开发板)目录leopard2a
 在目录下创建leopard2a．C，flash．C，memsetup．S
 以及Makefile，u-bot．1ds，config．mk文件
 ④ 在include／configs目录下创建leopard2a．h
 ⑤ 打开u-bot目录下Makefile文件，加入如下两行：
 leopard2a_config :    unconfig
 @./mkconfig $(@:_config=) arm arm926ejs leopard2a
 ⑥ 编译。运行命令：
 1. make leopard2a_config
 2. make
 编译成功．生成基本的u—b00t．
 ⑦ 烧写．把编译成的u-bot．bin
 至此移植u-bot过程结束．
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/27/course/embeded/lesson_14/" data-id="cj1zsm1qi000srkufkt7t9224" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/tip_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/22/course/embeded/tip_1/" class="article-date">
  <time datetime="2017-04-22T08:51:00.000Z" itemprop="datePublished">2017-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/22/course/embeded/tip_1/">ubuntu apt-get install 加速</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原理是把apt-get安装源切换成国内的，这里选择国内网易的镜像站点。</p>
<ul>
<li><p>备份/etc/apt/source.list文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo cp /etc/apt/source.list /etc/apt/source.list.old</div></pre></td></tr></table></figure>
</li>
<li><p>修改/etc/apt/source.list的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gedit /etc/apt/source.list</div></pre></td></tr></table></figure>
</li>
</ul>
<p>把/etc/apt/source.list的内容替换成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.163.com/ubuntu/ precise main restricted</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise main restricted</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-updates main restricted</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-updates main restricted</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise universe</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise universe</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-updates universe</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-updates universe</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise multiverse</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise multiverse</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-updates multiverse</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-updates multiverse</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-backports main restricted universe multiverse</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-security main restricted</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-security main restricted</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-security universe</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-security universe</div><div class="line">deb http://mirrors.163.com/ubuntu/ precise-security multiverse</div><div class="line">deb-src http://mirrors.163.com/ubuntu/ precise-security multiverse</div><div class="line">deb http://extras.ubuntu.com/ubuntu precise main</div><div class="line">deb-src http://extras.ubuntu.com/ubuntu precise main</div></pre></td></tr></table></figure></p>
<ul>
<li>安装源生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/22/course/embeded/tip_1/" data-id="cj1zsm1r8001arkufho6izox5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/course/embeded/lesson_13/" class="article-date">
  <time datetime="2017-03-26T08:51:00.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/26/course/embeded/lesson_13/">（13）Linux内核编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="准备源码和工具"><a href="#准备源码和工具" class="headerlink" title="准备源码和工具"></a>准备源码和工具</h4><h4 id="内核配置选项和编译"><a href="#内核配置选项和编译" class="headerlink" title="内核配置选项和编译"></a>内核配置选项和编译</h4><h4 id="内核编译过程"><a href="#内核编译过程" class="headerlink" title="内核编译过程"></a>内核编译过程</h4><hr>
<h5 id="准备源码和工具-1"><a href="#准备源码和工具-1" class="headerlink" title="准备源码和工具"></a>准备源码和工具</h5><p>Linux内核源码<a href="https://www.kernel.org/" target="_blank" rel="external">下载</a>，选择需要的版本。<br>这里使用OK6410自带的源码包和交叉工具链。清单如下：</p>
<ol>
<li><a href="http://pan.baidu.com/s/1i560zzf" target="_blank" rel="external">linux-3.0.1-2012-09-23.tar.gz</a></li>
<li><a href="http://pan.baidu.com/s/1hsE9Z72" target="_blank" rel="external">arm-linux-gcc-4.3.2.tgz</a></li>
</ol>
<h5 id="内核配置选项和编译-1"><a href="#内核配置选项和编译-1" class="headerlink" title="内核配置选项和编译"></a>内核配置选项和编译</h5><ul>
<li><p>arm-linux-gcc解压和配置</p>
<ol>
<li><p>解压arm-linux-gcc到根目录下，它会自动把文件解压到/usr/local目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$tar zxvf arm-linux-gcc-4.3.2.tgz -C /</div></pre></td></tr></table></figure>
</li>
<li><p>添加arm-linux-gcc的命令到当前shell环境变量<br>在/etc/profile文件，最后一行添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/usr/local/arm/4.3.2/bin:$PATH</div></pre></td></tr></table></figure>
<p>可用echo输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo export PATH=/usr/local/arm/4.3.2/bin:$PATH &gt;&gt; /etc/profile</div></pre></td></tr></table></figure>
<p>使环境变量生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ . /etc/profile</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>解压和配置Linux内核</p>
<ul>
<li><p>解压源码到当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf linux-3.0.1-2012-09-23.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>配置内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make menuconfig</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里可能会报错，提示需要ncurses-devel库，则安装之</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install ncurses-devel</div></pre></td></tr></table></figure>
<p>再次make后会出现一个界面框（ncurses库提供支持），可进行功能项的配置。<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328164923.png" alt="image"><br>配置交叉工具链<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328165541.png" alt="image"></p>
<ul>
<li>配置完，开始编译。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 告诉编译器启动8个编译任务，提高编译速度。根据自己CPU内核个数而定。</div><div class="line">$ make -j8</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里可能会报错，提示/lib/ld-linux.so.2:bad ELF intpreter.原因在64位系统调用了32位程序。<br>所以，安装32位的c语言程序包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install glibc.i686</div></pre></td></tr></table></figure>
<p>提示：error while loading shared libraries: libz.so.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install zlib.i686</div></pre></td></tr></table></figure>
<p>继续。。。<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328170632.png" alt="image"><br>中间可以还会报错，提示<br>Can’t use ‘defined(@array)’ (Maybe you should just omit the defined()?) at kernel/timeconst.pl<br>修改方法：<br>将if (!defined(@val))<br>改为if (!@val)</p>
<ul>
<li>编译成功！<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328172142.png" alt="image"></li>
</ul>
</li>
</ul>
<h5 id="内核编译过程-1"><a href="#内核编译过程-1" class="headerlink" title="内核编译过程"></a>内核编译过程</h5><p>当执行$ make menuconfig时会出现内核的配置界面，所有配置工具都是通过读取”arch/$(ARCH)Kconfig”文件来生成配置界面，这个文件就是所有配置的总入口，它会包含其他目录的Kconfig。<br>Kconfig的作用：Kconfig用来配置内核，它就是各种配置界面的源文件，内核的配置工具读取各个Kconfig文件，生成配置界面供开发人员配置内核，最后生成配置文件.config。Kconfig的语法可以参考“Documentation/kbuild/kconfig-language.txt”</p>
<p>Kconfig文件的基本要素：<br>config条目(entry)<br>  config TMPFS_POSIX_ACL<br>    bool “Tmpfs POSIX Access Control Lists”<br>    depends on TMPFS<br>    select GENERIC_ACL<br>    help<br>      POSIX Access Control Lists (ACLs) support permissions for users and<br>      groups beyond the owner/group/world scheme.<br>      To learn more about Access Control Lists, visit the POSIX ACLs for<br>      If you don’t know what Access Control Lists are, say N.</p>
<p>解析：<br>   config是关键字，表示一个配置选项的开始；紧跟着的TMPFS_POSIX<em>ACL是配置选项的名称，省略了前缀”CONFIG</em>“<br>   bool表示变量类型，即”CONFIG_ TMPFS_POSIX_ACL “的类型，有5种类型：bool、tristate、string、hex和int。</p>
<ul>
<li>bool变量的值：    y和n</li>
<li>tristate变量的值：y、n和m</li>
<li>string变量的值：  字符串</li>
<li>bool之后的字符串“Tmpfs POSIX Access Control Lists”是提示信息，在配置界面中上下移动光标选中它时，就可以通过按空格或回车键来设置CONFIG_ TMPFS_POSIX_ACL的值</li>
<li>depends on：表示依赖于XXX，“depends on TMPFS”表示只有当TMPFS配置选项被选中时，当前配置选项的提示信息才会出现，才能设置当前配置选项</li>
</ul>
<p>在内核中添加自己驱动模块：</p>
<ul>
<li>添加配置选项：在linux/drivers/char/Kconfig的endmenu前面一个菜单项，并勾选此项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config MY_HELLO</div><div class="line">	tristate &quot;Hello for test&quot;</div><div class="line">	depends on CPU_S3C6410</div><div class="line">	help</div><div class="line">		Hi, just a test.</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328203911.png" alt="image"></p>
<ul>
<li><p>新建驱动文件：linux/drivers/char/my-hello.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</div><div class="line">static int hello_init(void)</div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT &quot;Hello, world\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">static void hello_exit(void)</div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT &quot;Goodbye, cruel world\n&quot;);</div><div class="line">&#125;</div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div></pre></td></tr></table></figure>
</li>
<li><p>修改Makefile：linux/drivers/char/Makefile，在文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-$(CONFIG_MY_HELLO)			+= my-hello.o</div></pre></td></tr></table></figure>
</li>
<li><p>再次make<br><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_13/20170328211948.png" alt="image"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/course/embeded/lesson_13/" data-id="cj1zsm1qg000qrkuf1ldsqu0z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/25/course/embeded/lesson_12/" class="article-date">
  <time datetime="2017-03-25T08:51:00.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/course/embeded/lesson_12/">（12）Linux字符驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Linux系统的设备"><a href="#Linux系统的设备" class="headerlink" title="Linux系统的设备"></a>Linux系统的设备</h4><h4 id="Linux设备驱动开发"><a href="#Linux设备驱动开发" class="headerlink" title="Linux设备驱动开发"></a>Linux设备驱动开发</h4><h4 id="Linux字符驱动"><a href="#Linux字符驱动" class="headerlink" title="Linux字符驱动"></a>Linux字符驱动</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_12/link.png" alt="image"></p>
<h5 id="Linux系统的设备-1"><a href="#Linux系统的设备-1" class="headerlink" title="Linux系统的设备"></a>Linux系统的设备</h5><p>Linux系统中的设备分为三大类：字符设备，块设备，网络设备。字符设备就是以字节流形式通讯的I/O设备，常见的字符设备有键盘，鼠标，串口等。块设备则是以传输固定大小来访问设备。比如硬盘，U盘等等。网络设备跟块设备类似，但它能异步的接收来自外部的数据。</p>
<h5 id="Linux设备驱动开发-1"><a href="#Linux设备驱动开发-1" class="headerlink" title="Linux设备驱动开发"></a>Linux设备驱动开发</h5><p>Linux中一切皆文件。驱动程序作用就是提供上层应用访问底层硬件的桥梁作用。<br>从上层应用程序访问硬件设备的角度，Linux驱动模型必须提供一组对设备访问的操作集供上层调用之。这里主要涉及到Linux内核封装好的struct file_operations，驱动程序的编写，主要工作就是实现struct file_operations里面的方法。另外，Linux内核要提供如何管理设备的方法。比如如何申请设备编号，名字，内核数据结构，cdev数据结构。</p>
<p>先来看看操作集, struct file_operations<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">struct file_operations &#123;</div><div class="line">    struct module *owner;   //THIS_MODULE</div><div class="line">    // 读数据</div><div class="line">    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">    // 写数据</div><div class="line">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div><div class="line">    // 映射内核空间到用户空间</div><div class="line">    int (*mmap) (struct file *, struct vm_area_struct *);</div><div class="line">    // 读写设备参数、读设备状态、控制设备</div><div class="line">    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line"></div><div class="line">    // 打开设备</div><div class="line">    int (*open) (struct inode *, struct file *);</div><div class="line">    // 关闭设备</div><div class="line">    int (*release) (struct inode *, struct file *);</div><div class="line">    // 刷新设备</div><div class="line">    int (*flush) (struct file *, fl_owner_t id);</div><div class="line">    // 文件定位</div><div class="line">    loff_t (*llseek) (struct file *, loff_t, int);</div><div class="line"></div><div class="line">    // 异步通知</div><div class="line">    int (*fasync) (int, struct file *, int);</div><div class="line">    // POLL机制</div><div class="line">    unsigned int (*poll) (struct file *, struct poll_table_struct *);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>读和写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 读数据</div><div class="line">ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">// 写数据</div><div class="line">ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div></pre></td></tr></table></figure></p>
<p>read和write的buff参数是用户空间指针。因此，内核提供了专门的函数用于访问用户空间的指针，用于数据的来回“穿越”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 把数据从用户空间搬运到内核空间</div><div class="line">int copy_from_user(void *to,const void_user *from,int n)</div><div class="line">// 把数据从内核空间搬运到用户空间</div><div class="line">int copy_to_user(void_user *to,const void *from,int n)</div></pre></td></tr></table></figure></p>
<p>重要数据结构</p>
<ul>
<li>struct file<ul>
<li>代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的struct file 。它由内核在打开文件时创建，在文件关闭后释放</li>
</ul>
</li>
<li>struct inode<ul>
<li>用来记录文件的物理上的信息。因此，它和代表打开文件的file结构是不同的。一个文件可以对应多个file结构，但只有一个inode结构。</li>
</ul>
</li>
<li>struct file_operations<ul>
<li>一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数，这些函数实现一个特别的操作，对于不支持的操作保留为NULL。</li>
</ul>
</li>
</ul>
<h6 id="申请设备号"><a href="#申请设备号" class="headerlink" title="申请设备号"></a>申请设备号</h6><ul>
<li>主设备号用来标识与设备文件相连的驱动程序。</li>
<li>次设备号被驱动程序用来辨别操作的是哪个设备。<br>dev_t   其实质为unsigned int 32 位整数，其中高12位为主设备号，低20位为次设备号。<br>从dev_t 中分解主次设备号<br>主设备号 MAJOR（dev_t dev）<br>次设备号 MINOR（dev_t dev）</li>
<li><p>分配设备号</p>
<ul>
<li><p>动态申请<br>方法：使用alloc_chrdev_region分配设备号<br>优点：简单，易于驱动推广<br>缺点：无法在安装驱动前创建设备文件（因为安装前没有分配到主设备号）<br>解决办法：安装驱动后，从/proc/devices 中查询设备号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name)</div><div class="line">功能</div><div class="line">	动态申请count个设备号，第1个设备号的次设备号为  baseminor</div><div class="line">参数</div><div class="line">	dev 分配到的设备号</div><div class="line">	baseminor 起始次设备号</div><div class="line">	count 要注册的设备号个数</div><div class="line">	name 设备名</div></pre></td></tr></table></figure>
</li>
<li><p>静态申请<br>方法：通过cat /proc/devices 确定一个没有使用的主设备号，使用register_chrdev_region函数注册设备号。<br>优点：简单<br>缺点：一旦驱动被广泛使用，这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int register_chrdev_region(dev_t from,unsigned count,const char *name)</div><div class="line">功能</div><div class="line">	注册从from开始的count个设备号（主设备号不变，次设备号增加，如果此设备号溢出，主设备号加1）</div><div class="line">参数</div><div class="line">	from 要注册的第一个设备号</div><div class="line">	count 要注册的设备号个数</div><div class="line">	name 设备名</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h6 id="注销设备"><a href="#注销设备" class="headerlink" title="注销设备"></a>注销设备</h6><p>不论使用任何方法分配设备号，都应该在不使用它们时释放这些设备号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void unregister_chrdev_region(dev_t from,unsigned count)</div><div class="line">功能</div><div class="line">	释放从from 开始的count 个设备号</div></pre></td></tr></table></figure></p>
<h6 id="利用mknode命令手动创建设备节点"><a href="#利用mknode命令手动创建设备节点" class="headerlink" title="利用mknode命令手动创建设备节点"></a>利用mknode命令手动创建设备节点</h6><p>mknode用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mknod devicename type major minnor</div><div class="line"></div><div class="line">devicename 	设备文件名</div><div class="line">type 		    设备文件类型</div><div class="line">major 	    主设备号</div><div class="line">minor 	    次设备号</div><div class="line">例子：</div><div class="line">mknode ok6410sel c 232 0</div></pre></td></tr></table></figure></p>
<h4 id="Linux字符驱动和应用测试例子"><a href="#Linux字符驱动和应用测试例子" class="headerlink" title="Linux字符驱动和应用测试例子"></a>Linux字符驱动和应用测试例子</h4><p>简单的字符驱动程序mychar.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">#include &lt;linux/kernel.h&gt;</div><div class="line">#include &lt;linux/fs.h&gt;</div><div class="line">#include &lt;linux/errno.h&gt;</div><div class="line">#include &lt;linux/types.h&gt;</div><div class="line">#include &lt;linux/fcntl.h&gt;</div><div class="line">#include &lt;linux/cdev.h&gt;</div><div class="line">#include &lt;linux/version.h&gt;</div><div class="line">#include &lt;linux/vmalloc.h&gt;</div><div class="line">#include &lt;linux/ctype.h&gt;</div><div class="line">#include &lt;linux/pagemap.h&gt;</div><div class="line">#include &lt;linux/ioctl.h&gt;</div><div class="line">#include &lt;linux/slab.h&gt;</div><div class="line"></div><div class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</div><div class="line"></div><div class="line">#define DEMO_MAJOR 225</div><div class="line">#define DEMO_MINOR 0</div><div class="line">#define DEV_NAME &quot;mychar&quot;</div><div class="line"></div><div class="line">struct demo_dev &#123;</div><div class="line">	struct cdev cdev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/*</div><div class="line">尽管这常常是对设备文件进行的第一个操作， 不要求驱动声明一个对应的方法。 如果这个项是 NULL，设备打开一直成功，但是你的驱动不会得到通知。</div><div class="line">*/</div><div class="line">int test_open (struct inode *inode, struct file *filp)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter open\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">在文件结构被释放时引用这个操作。如同 open、release 可以为 NULL。</div><div class="line">*/</div><div class="line">int test_release (struct inode *inode,  struct file *filp)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter release\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">从设备中读取数据</div><div class="line">*/</div><div class="line">ssize_t test_read (struct file *filp, char __user *buf, size_t size, loff_t *offset)</div><div class="line">&#123;</div><div class="line">	printk(&quot;user buffer %s\n&quot;, buf);</div><div class="line">	printk(&quot;enter read\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">向设备发送数据</div><div class="line">*/</div><div class="line">ssize_t test_write (struct file *filp, const char __user *buf, size_t size, loff_t *offset)</div><div class="line">&#123;</div><div class="line">	printk(&quot;enter write\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制设备</div><div class="line">*/</div><div class="line">int test_ioctl (struct file *filp, unsigned int cmd, unsigned long args) &#123;</div><div class="line">	printk(&quot;enter ioctl\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;				</div><div class="line"></div><div class="line">struct demo_dev *demo_devices;</div><div class="line"></div><div class="line">static struct file_operations fos = &#123;</div><div class="line">	.owner = THIS_MODULE,</div><div class="line">	.open = test_open,</div><div class="line">	.release = test_release,</div><div class="line">	.read = test_read,</div><div class="line">	.write = test_write,</div><div class="line">	.unlocked_ioctl = test_ioctl</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static int reg_dev()</div><div class="line">&#123;</div><div class="line">	int result;</div><div class="line">	dev_t dev = 0;</div><div class="line"></div><div class="line">  // 生成设备号</div><div class="line">	dev = MKDEV(DEMO_MAJOR, DEMO_MINOR);</div><div class="line">  // 申请注册一个字符设备</div><div class="line">	result = register_chrdev_region(dev, 1, DEV_NAME);</div><div class="line">	if (result &lt; 0) &#123;</div><div class="line">		printk(KERN_WARNING &quot;DEMO: can&apos;t get major %d\n&quot;, DEMO_MAJOR);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">  // 申请设备空间</div><div class="line">	demo_devices = kmalloc(sizeof(struct demo_dev), GFP_KERNEL);</div><div class="line">	if (!demo_devices) &#123;</div><div class="line">		result = -ENOMEM;</div><div class="line">		//goto fail;</div><div class="line">	&#125;</div><div class="line">  // 设备空间清理</div><div class="line">	memset(demo_devices, 0, sizeof(struct demo_dev));</div><div class="line">  // 对设备空间赋值</div><div class="line">	cdev_init(&amp;demo_devices-&gt;cdev, &amp;fos);</div><div class="line">	demo_devices-&gt;cdev.owner = THIS_MODULE;</div><div class="line">	demo_devices-&gt;cdev.ops = &amp;fos;</div><div class="line">	//将创建的字符设备与file_operations中各函数操作连接起来</div><div class="line">	result = cdev_add(&amp;demo_devices-&gt;cdev, dev, 1);</div><div class="line">	if (result) &#123;</div><div class="line">		printk(KERN_NOTICE &quot;error %d adding demo\n&quot;, result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	printk(&quot;call init \n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void unreg_dev()</div><div class="line">&#123;</div><div class="line">	dev_t devno = MKDEV(DEMO_MAJOR, DEMO_MINOR);</div><div class="line"></div><div class="line">	if (demo_devices) &#123;</div><div class="line">		cdev_del(&amp;demo_devices-&gt;cdev);</div><div class="line">		kfree(demo_devices);</div><div class="line">	&#125;</div><div class="line">	unregister_chrdev_region(devno, 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int hello_init(void)</div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT &quot;Hello, world\n&quot;);</div><div class="line"></div><div class="line">	reg_dev();</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void hello_exit(void)</div><div class="line">&#123;</div><div class="line">	unreg_dev();</div><div class="line">	printk(KERN_ALERT &quot;Goodbye, cruel world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div></pre></td></tr></table></figure></p>
<p>应用程序测试驱动程序test_mychar.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;linux/rtc.h&gt;</div><div class="line">#include &lt;linux/ioctl.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define COMMAND1 1</div><div class="line">#define COMMAND2 2</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int fd;</div><div class="line">	int i;</div><div class="line">	char data[256] = &#123;0&#125;;</div><div class="line">	int retval;</div><div class="line"></div><div class="line">  // 1. 以读写方式打开/dev/mychar设备</div><div class="line">	fd = open(&quot;/dev/mychar&quot;, O_RDWR);</div><div class="line">	printf(&quot;fd = %d\n&quot;, fd);</div><div class="line">  // 打开失败程序退出</div><div class="line">	if (fd &lt; 0) &#123;</div><div class="line">		perror(&quot;open error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;open /dev/mychar successfully\n&quot;);</div><div class="line"></div><div class="line">  // 2. 设备io控制指令</div><div class="line">	retval = ioctl(fd, 100, 11);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;ioctl error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;ioctl command 1 successfully\n&quot;);</div><div class="line"></div><div class="line">  // 3. 向设备写入数据</div><div class="line">	retval = write(fd, &quot;testchar&quot;, 7);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;write error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">/*</div><div class="line">	retval = lseek(fd, 0, 0);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;lseek error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">*/</div><div class="line">  // 4. 从设备读取数据</div><div class="line">	retval = read(fd, data, 10);</div><div class="line">	if (retval == -1) &#123;</div><div class="line">		perror(&quot;read error\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;read successfully: %s\n&quot;, data);</div><div class="line">  // 5. 关闭设备</div><div class="line">  close(fd);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="操作结果"><a href="#操作结果" class="headerlink" title="操作结果"></a>操作结果</h6><ul>
<li>利用Makefile编译模块mychar.c，gcc编译应用程序test_mychar.c。</li>
<li><p>创建设备节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mknod /dev/mychar c 225 0</div></pre></td></tr></table></figure>
</li>
<li><p>运行a.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo ./a.out</div><div class="line">fd = 3</div><div class="line">open /dev/mychar successfully</div><div class="line">ioctl command 1 successfully</div><div class="line">read successfully:</div></pre></td></tr></table></figure>
</li>
<li><p>查看驱动打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ dmesg</div><div class="line">...</div><div class="line">[26562.470512] enter open</div><div class="line">[26562.472281] enter ioctl</div><div class="line">[26562.472302] enter write</div><div class="line">[26562.472304] user buffer</div><div class="line">[26562.472304] enter read</div><div class="line">[26562.472325] enter release</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/25/course/embeded/lesson_12/" data-id="cj1zsm1qa000lrkufs6ud1d5o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/24/course/embeded/lesson_11/" class="article-date">
  <time datetime="2017-03-24T13:31:00.000Z" itemprop="datePublished">2017-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/course/embeded/lesson_11/">（11）Linux模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Linux模块简介"><a href="#Linux模块简介" class="headerlink" title="Linux模块简介"></a>Linux模块简介</h4><h4 id="模块入门"><a href="#模块入门" class="headerlink" title="模块入门"></a>模块入门</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_11/link.jpg" alt="image"></p>
<h5 id="Linux模块简介-1"><a href="#Linux模块简介-1" class="headerlink" title="Linux模块简介"></a>Linux模块简介</h5><p>Linux系统按照程序运行空间（或权限）分用户空间和内核空间，内核空间运行linux内核程序代码。Linux内核代码属于单内核（monolithic kernel），其优点是运行效率高。缺点是所有的内核代码都集成一体，代码的耦合度高，可扩展性和维护性差。LKM模块机制解决了linux内核的缺陷，其提供了内核可以动态装载和卸载一些程序代码，这类代码称之为模块。</p>
<p>模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在需要运行时被动态链接到内核内存空间运行，这点和运行在用户空间的应用程序有很大不同。若一个模块程序用于管理某些硬件设备，如网卡，键盘、摄像头等，这种模块称为设备驱动模块。</p>
<h5 id="内核如何管理模块"><a href="#内核如何管理模块" class="headerlink" title="内核如何管理模块"></a>内核如何管理模块</h5><p>1、为了使内核模块访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改这些符号表；<br>2、有些模块要求利用其他模块的功能，因此，内核要维护模块之间的依赖性。<br>3、内核必须能够在卸载模块时通知模块，并且要释放分配给模块的内存和中断等资源； 　　<br>4、内核版本和模块版本的不兼容，也可能导致系统崩溃，因此，严格的版本检查是必需的。</p>
<h5 id="模块入门-1"><a href="#模块入门-1" class="headerlink" title="模块入门"></a>模块入门</h5><ol>
<li><p>来一个hello world模块程序，hello_module.c文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line"></div><div class="line">// 声明模块支持协议</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line"></div><div class="line">// 模块安装入口，被insmod命令调用</div><div class="line">int __init init_hello_module(void)</div><div class="line">&#123;</div><div class="line">    //用dmesg命令可以查看该信息</div><div class="line">    printk(&quot;Hello kernel, I am a module.\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//模块卸载出口，被rmmod命令调用</div><div class="line">void __exit cleanup_hello_module(void)</div><div class="line">&#123;</div><div class="line">    printk(&quot;Good bye kernel, from a module!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//绑定装载和卸载函数</div><div class="line">module_init(init_hello_module);</div><div class="line">module_exit(cleanup_hello_module);</div></pre></td></tr></table></figure>
</li>
<li><p>再写一个Makefile，编译module。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">obj-m := modules.o               #要生成的模块名     </div><div class="line">modules-objs:= hello_module.o     #生成这个模块名所需要的目标文件</div><div class="line"></div><div class="line">KDIR := /lib/modules/`uname -r`/build</div><div class="line">PWD := $(shell pwd)</div><div class="line"></div><div class="line">default:</div><div class="line">  make -C $(KDIR) M=$(PWD) modules</div><div class="line"></div><div class="line">clean:</div><div class="line">  rm -rf *.o .* .cmd *.ko *.mod.c .tmp_versions</div></pre></td></tr></table></figure>
<p>说明：<br>obj-m  : 指定要声称的模块名字。格式为obj-m := &lt;模块名&gt;.o<br>modules-objs：声称模块modules需要的目标文件。格式为&lt;模块名&gt;-objs := &lt;目标文件&gt;<br>切记：模块名字不能与目标文件名字相同。如在这里模块名不能取成hello_module；<br>KDIR   ：指定操作系统内核编译目录。若目录不存在通过sudo dnf install kernel-devel<br>M=     ：指定源文件的位置。<br>PWD    ：当前工作路径，通过make执行shell命令$(shell pwd)得到。</p>
</li>
<li><p>编译、安装、卸载module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">$ ls</div><div class="line">hello_module.c  Makefile    modules.mod.c  modules.o      Module.symvers</div><div class="line">hello_module.o  modules.ko  modules.mod.o  modules.order</div><div class="line">$ sudo insmod modules.ko</div><div class="line">$ sudo rmmod  modules</div><div class="line">$ demsg</div><div class="line">...</div><div class="line">[ 1186.777496] Hello kernel,I am a module.</div><div class="line">[ 1580.009145] Good bye kernel, from a module!</div></pre></td></tr></table></figure>
</li>
<li><p>安装模块后，查看其信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/modules</div><div class="line">modules 16384 0 - Live 0xffffffffc078f000 (OE)</div><div class="line">nls_utf8 16384 1 - Live 0xffffffffc0785000</div><div class="line">isofs 40960 1 - Live 0xffffffffc0776000</div><div class="line">...</div><div class="line">$ modinfo modules.ko</div><div class="line">filename:       /home/highsung/dev/lesson_11/modules.ko</div><div class="line">license:        GPL</div><div class="line">depends:        </div><div class="line">vermagic:       4.8.6-300.fc25.x86_64 SMP mod_unload</div></pre></td></tr></table></figure>
</li>
<li><p>给模块添加更多信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 作者</div><div class="line">MODULE_AUTHOR(&quot;Highsung tech,&lt;1307814956@qq.com&gt;&quot;);</div><div class="line">// 版本</div><div class="line">MODULE_VERSION(&quot;0.1&quot;);</div><div class="line">// 描述模块作用</div><div class="line">MODULE_DESCRIPTION(&quot;Just for test&quot;);</div><div class="line">// 模块别名</div><div class="line">MODULE_ALIAS(&quot;Simple module&quot;);</div><div class="line">// 模块源hash值</div><div class="line">MODULE_INFO(srcversion,&quot;123zxcv&quot;);</div><div class="line">MODULE_INFO(intree,&quot;Y&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>重新编译模块并装载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ modinfo modules.ko</div><div class="line">filename:       /home/highsung/dev/lesson_11/modules.ko</div><div class="line">intree:         Y</div><div class="line">srcversion:     123zxcv</div><div class="line">alias:          Simple module</div><div class="line">description:    Just for test</div><div class="line">version:        0.1</div><div class="line">author:         Highsung tech,&lt;1307814956@qq.com&gt;</div><div class="line">license:        GPL</div><div class="line">srcversion:     CA56BD7A1BEE0427483B64A</div><div class="line">depends:        </div><div class="line">vermagic:       4.8.6-300.fc25.x86_64 SMP mod_unload</div></pre></td></tr></table></figure></p>
<h5 id="模块传参"><a href="#模块传参" class="headerlink" title="模块传参"></a>模块传参</h5><p>在用户态的C语言中，函数的传参使用main(int argc, char* argv)，内核的传参使用了另外一种方法：<br>步骤一、在内核函数中用module_param指定模块参数。<br>步骤二、加载内核时传递参数给模块。</p>
<p>module_param函数使用方法：<br>module_param(name, type, perm)<br>name：内核参数的名称，自定义；<br>type：内核参数的类型，常见的类型byte、short、int、long、ulong、bool 、charp(字符指针);<br>perm：内核参数的权限S_IRUGO(对模块参数具有读权限)。其实权限和文件的权限差不多，具体可以查看”/usr/include/linux/stat.h”。</p>
<p>  再编写一个param_module.c模块源文件：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line"></div><div class="line">// 声明模块支持协议</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line">MODULE_AUTHOR(&quot;Highsung tech,&lt;1307814956@qq.com&gt;&quot;);</div><div class="line">MODULE_VERSION(&quot;0.1&quot;);</div><div class="line"></div><div class="line">// 定义整数和字符串</div><div class="line">int testNum = 10;</div><div class="line">char *testStr = &quot;param module&quot;;</div><div class="line"></div><div class="line">// 模块安装入口，被inmod命令调用</div><div class="line">int __init init_hello_module(void)</div><div class="line">&#123;</div><div class="line">	printk(&quot;Hello kernel,I am a module.\n&quot;);</div><div class="line">	printk(&quot;test num=%d, str=%s\n&quot;,testNum, testStr);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 模块卸载出口，被rmmod命令调用</div><div class="line">void __exit cleanup_hello_module(void)</div><div class="line">&#123;</div><div class="line">	printk(&quot;Good bye kernel, from a module!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 绑定装卸和卸载函数</div><div class="line">module_init(init_hello_module);</div><div class="line">module_exit(cleanup_hello_module);</div><div class="line">// 绑定整数和字符串</div><div class="line">module_param(testNum, int, 0644);</div><div class="line">module_param(testStr, charp, 0644);</div></pre></td></tr></table></figure></p>
<p>  卸载先前的模块，再次装载之。正确打印传入的整数和字符串。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo insmod modules.ko testNum=123 testStr=&apos;abc&apos;</div><div class="line">$ dmesg</div><div class="line">...</div><div class="line">[10389.957834] Hello kernel,I am a module.</div><div class="line">[10389.957836] test num=123, str=abc</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/24/course/embeded/lesson_11/" data-id="cj1zsm1qc000mrkufcfecaf9l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/course/embeded/lesson_10/" class="article-date">
  <time datetime="2017-03-23T06:04:00.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/course/embeded/lesson_10/">（10）Makefile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h4><h4 id="Makefile内部规则"><a href="#Makefile内部规则" class="headerlink" title="Makefile内部规则"></a>Makefile内部规则</h4><h4 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_10/link.png" alt="image"></p>
<h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><p>前面我们聊过了gcc编译源码的一些常用指令，当源代码很多时，逐条逐条的输入编译是一件细思极恐的事情！有没更加简单、高效的方式呢？当然有，那就是Makfile。</p>
<p>当一个工程中的源文件越来越多时，工程师通常会按类型、功能、模块分别放在若干个目录中，Makefile中定义一系列的规则来指定，那些文件先编译，那些后编译，那些文件修改后，依赖它的文件需要重新编译，甚至进行更复杂的功能操作，比如清除中间和目标文件，安装编译好的文件等。</p>
<p>总之，Makefile是用来定义整个工程的编译规则的，一旦写好，只需要一个make命令，整个工程自动完成编译，极大的提高了软件开发效率。</p>
<h5 id="Makefile内部规则-1"><a href="#Makefile内部规则-1" class="headerlink" title="Makefile内部规则"></a>Makefile内部规则</h5><p>下面是Makefile中最核心的结构：<br>target: prerequisites<br>  command<br>…<br>解释：<br>target 可以是一个目标文件，也可以是执行文件，还可以是一个标签。标签这种特性，在后面的“伪目标”介绍。</p>
<p>prerequisite 是生成target所需要的文件或目标。</p>
<p>command make需要执行命令，通过执行command来生成target。</p>
<p>总结，target依赖于prerequisites中的条件（文件），生成target的规则定义在command中，由make执行。如果prerequisites中的文件比target目标要新，command所定义的命令就会被执行。</p>
<h5 id="Makefile实例分析"><a href="#Makefile实例分析" class="headerlink" title="Makefile实例分析"></a>Makefile实例分析</h5><p>一个工程有3个头文件，8个C文件，为编译得到可执行程序。Makefile文件定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">edit: main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">  cc -o edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">main.o: main.c defs.h</div><div class="line">  cc -c main.c</div><div class="line">kbd.o: kbd.c defs.h command.h</div><div class="line">  cc -c kbd.c</div><div class="line">command.o: command.c defs.h command.h</div><div class="line">  cc -c command.c</div><div class="line">display.o: dispaly.c defs.h buffer.h</div><div class="line">  cc -c display.c</div><div class="line">insert.o: insert.c defs.h buffer.h</div><div class="line">  cc -c insert.c</div><div class="line">search.o: search.c defs.h buffer.h</div><div class="line">  cc -c search.c</div><div class="line">files.o:files.c defs.h buffer.h command.h</div><div class="line">  cc -c files.c</div><div class="line">utils.o:utils.c defs.h</div><div class="line">  cc -c utils.c</div><div class="line">clean:</div><div class="line">  rm edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>说明：<br>edit目标依赖main.o kbd.o command.o display.o insert.o search.o files.o utils.o这些文件，通过执行命令cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o，生成edit可执行文件。</p>
<p>同理，main.o目标依赖main.c defs.h这些文件，通过执行命令cc -c main.c，生成main.o文件。</p>
<p>clean目标，没有依赖文件，通过执行命令rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o达到目的。</p>
<p>Makefile中的反斜杠（\）是续行符的意思。在Linux终端切换到该目录下，执行“make”命令就可以生成可执行文件edit。如果要删除可执行文件和所有中间文件，执行“make clean”就可以了。</p>
<h6 id="注意：命令行必须以Tab键开头，不然make会报错。"><a href="#注意：命令行必须以Tab键开头，不然make会报错。" class="headerlink" title="注意：命令行必须以Tab键开头，不然make会报错。"></a>注意：命令行必须以Tab键开头，不然make会报错。</h6><h5 id="make命令-1"><a href="#make命令-1" class="headerlink" title="make命令"></a>make命令</h5><ol>
<li><p>make命令用法<br>makefile有点像Shell脚本一样，它是靠make命令解释执行的。make命令是GNU的工程化编译工具。<br>make命令语法：make [选项] 参数 Makefile名<br>-f：指定“makefile”文件；<br>-i：忽略命令执行返回的出错信息；<br>-s：沉默模式，在执行之前不输出相应的命令行信息；<br>-r：禁止使用build-in规则；<br>-n：非执行模式，输出所有执行命令，但并不执行；<br>-t：更新目标文件；<br>-q：make操作将根据目标文件是否已经更新返回”0”或非”0”的状态信息；<br>-p：输出所有宏定义和目标文件描述；<br>-d：Debug模式，输出有关文件和检测时间的详细信息。<br>-c dir：在读取 makefile 之前改变到指定的目录dir；<br>-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；<br>-h：help文挡，显示所有的make选项；<br>-w：在处理 makefile 之前和之后，都显示工作目录。</p>
</li>
<li><p>make如何工作</p>
</li>
</ol>
<ul>
<li>默认情况下，我们输入make命令，那么make会在当前目录下找名字为“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找到文件中的第一个目标执行。在上面的例子中，第一个目标就是edit。<br>如果找不到makefile则提示“无目标”。</li>
<li>如果edit不存在，或edit所依赖的.o文件修改时间比edit文件新，那么执行后面所定义的命令来生成edit文件。</li>
<li>各个.o文件同理类推。</li>
</ul>
<h5 id="改进makefile"><a href="#改进makefile" class="headerlink" title="改进makefile"></a>改进makefile</h5><ul>
<li>变量的使用<br>先看看第一个target<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">edit: main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">  cc -o edit main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有重复两次的main.o kbd.o command.o display.o insert.o search.o files.o utils.o。<br>定义一个变量来代替它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">cc -o edit $objects</div></pre></td></tr></table></figure></p>
<p>是不是简洁一点了。</p>
<ul>
<li>使用make自动推到功能<br>GNU的make会自动推导文件以及依赖关系后面的命令。换句话说，make看到something.o时，会自动推导出cc -c something.c命令出来。所以上面的makefile可以写成：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">  cc -o $objects</div><div class="line">main.o: defs.h</div><div class="line">kbd.o: defs.h command.h</div><div class="line">command.o: defs.h command.h</div><div class="line">display.o: defs.h buffer.h</div><div class="line">insert.o: defs.h buffer.h</div><div class="line">search.o: defs.h buffer.h</div><div class="line">files.o: defs.h buffer.h command.h</div><div class="line">utils.o: defs.h</div><div class="line">clean:</div><div class="line">  rm edit $objects</div></pre></td></tr></table></figure>
</li>
</ul>
<p>是不是更简洁了。</p>
<ul>
<li>使用make隐式规则进行到底<br>现在看到还有一堆的.h文件，再次收拢变成<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">insert.o search.o files.o utils.o</div><div class="line">edit: $objects</div><div class="line">  cc -o $objects</div><div class="line">$objects:defs.h kbd.o command.o files.o:command.h \</div><div class="line">dispaly.o insert.o search.o files.o:buffer.h</div><div class="line">.PHONY:clean</div><div class="line">clean:</div><div class="line">  -rm edit $objects</div></pre></td></tr></table></figure>
</li>
</ul>
<p>是不是简洁得有点懵了，过于简单不太好理解。</p>
<ul>
<li><p>伪目标<br>上面的PHONY为什么要加在clean的前面？<br>假如当前目录下存在一个名叫clean的文件，那么执行make clean时，make发现clean文件存在，就不会执行make clean指令，进而不会执行删除任何文件。<br>怎么解决这个问题？这时PHONY就登场了。<br>.PHONY: clean就是声明clean是一个“伪目标”，告诉make执行clean目标时不要去检查当前目录下的clean文件是否存在，始终执行clean目标，即-rm edit $objects。<br>rm命令前加一个减号的意思是，忽略删除过程的一些文件不存在等情况。</p>
</li>
<li><p>Makefile中引用其他Makefile<br>在上面的例子中没有演示，Makefile包含其他Makefile的情形，其实Makefile可以像C语言中include其他头文件一样。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/course/embeded/lesson_10/" data-id="cj1zsm1qe000orkufqr3sjgf5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/tools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/course/embeded/tools/" class="article-date">
  <time datetime="2017-03-23T06:04:00.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/course/embeded/tools/">ARM Linux开发工具下载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ARM Linux交叉工具链下载<br><a href="http://www.veryarm.com/arm-none-linux-gnueabi-gcc" target="_blank" rel="external">http://www.veryarm.com/arm-none-linux-gnueabi-gcc</a></p>
<p>笔记<br>udev详解<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-udev/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-udev/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/course/embeded/tools/" data-id="cj1zsm1rh001jrkufm19mipb4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/22/course/embeded/lesson_9/" class="article-date">
  <time datetime="2017-03-22T08:52:00.000Z" itemprop="datePublished">2017-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/22/course/embeded/lesson_9/">（9）gdb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="gdb简介"><a href="#gdb简介" class="headerlink" title="gdb简介"></a>gdb简介</h4><h4 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h4><h4 id="gdb进阶"><a href="#gdb进阶" class="headerlink" title="gdb进阶"></a>gdb进阶</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_9/link.jpg" alt="image"></p>
<h5 id="gdb简介-1"><a href="#gdb简介-1" class="headerlink" title="gdb简介"></a>gdb简介</h5><p>GDB, the GNU Project debugger, allows you to see what is going on ‘inside’ another program while it executes – or what another program was doing at the moment it crashed.</p>
<p>The program being debugged can be written in Ada, C, C++, Objective-C, Pascal (and many other languages). Those programs might be executing on the same machine as GDB (native) or on another machine (remote). GDB can run on most popular UNIX and Microsoft Windows variants.</p>
<p>GDB，GNU项目调试器，可以让您看到在执行另一个程序时发生了什么 - 或者其他程序在崩溃时正在做什么。</p>
<p>被调试的程序可以用Ada，C，C ++，Objective-C，Pascal（和许多其他语言）编写。 这些程序可能与GDB（本地）或另一台机器（远程）在同一台机器上执行。 GDB可以运行在大多数流行的UNIX和Microsoft Windows中。</p>
<h4 id="程序调试-1"><a href="#程序调试-1" class="headerlink" title="程序调试"></a>程序调试</h4><ul>
<li>gdb常用指令</li>
</ul>
<ol>
<li><p>检测gdb是否安装及版本号，若未安装gdb会提示“未找到命令”。fedora25默认已安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> $ gdb -v</div><div class="line">GNU gdb (GDB) Fedora 7.12-24.fc25</div><div class="line">Copyright (C) 2016 Free Software Foundation, Inc.</div></pre></td></tr></table></figure>
</li>
<li><p>编写test.c程序，内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int sum(int n)</div><div class="line">&#123;</div><div class="line">    int sum=0;</div><div class="line">    for(int i=0; i&lt;=n; i++)</div><div class="line">    &#123;</div><div class="line">	sum += i;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argv, char *args[])</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    long result=0;</div><div class="line">    for(i=1; i&lt;=10; i++)</div><div class="line">    &#123;</div><div class="line">        result += i;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;result[1-10]=%d\n&quot;,result);</div><div class="line">    printf(&quot;result[1-100]=%d\n&quot;,sum(100));</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译debug版本的testd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -o testd -g test.c</div></pre></td></tr></table></figure>
</li>
<li><p>gdb载入test，list或l查看源码，回车可继续浏览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  $ gdb testd</div><div class="line">  (gdb) list</div><div class="line">2</div><div class="line">3	int sum(int n)</div><div class="line">4	&#123;</div><div class="line">5	    int sum=0;</div><div class="line">6	    for(int i=0; i&lt;=n; i++)</div><div class="line">7	    &#123;</div><div class="line">8		sum += i;</div><div class="line">9	    &#125;</div><div class="line">10	    return sum;</div><div class="line">11	&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
<li><p>设置断点，break 行号，break 函数名，info break 查看断点信息，break也可简写成b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  (gdb) break 19</div><div class="line">Breakpoint 1 at 0x400544: file test.c, line 19.</div><div class="line">(gdb) break sum</div><div class="line">Breakpoint 2 at 0x4004fd: file test.c, line 5.</div><div class="line">(gdb) info break</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">2       breakpoint     keep y   0x00000000004004fd in sum at test.c:5</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
</li>
<li><p>清除断点，clear 行号，clear 函数名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  (gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">	breakpoint already hit 10 times</div><div class="line">2       breakpoint     keep y   0x00000000004004fd in sum at test.c:5</div><div class="line">	breakpoint already hit 1 time</div><div class="line">  第二个断点被清除</div><div class="line">(gdb) clear 5</div><div class="line">Deleted breakpoint 2</div><div class="line">(gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000400544 in main at test.c:19</div><div class="line">	breakpoint already hit 10 times</div></pre></td></tr></table></figure>
</li>
<li><p>开始调试，输入run或r，停在第一个断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  (gdb) run</div><div class="line">Starting program: /home/highsung/dev/lesson_9/test</div><div class="line">Missing separate debuginfos, use: dnf debuginfo-install glibc-2.24-4.fc25.x86_64</div><div class="line"></div><div class="line">Breakpoint 1, main (argv=1, args=0x7fffffffe2b8) at test.c:19</div><div class="line">19	        result += i;</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
</li>
<li><p>单步执行，输入next或n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  (gdb) next</div><div class="line">17	    for(i=1; i&lt;=10; i++)</div><div class="line">(gdb) n</div><div class="line"></div><div class="line">Breakpoint 1, main (argv=1, args=0x7fffffffe2b8) at test.c:19</div><div class="line">19	        result += i;</div><div class="line">(gdb) n</div><div class="line">17	    for(i=1; i&lt;=10; i++)</div><div class="line">(gdb) n</div></pre></td></tr></table></figure>
</li>
<li><p>查看变量值，输入print或p</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  (gdb) print i</div><div class="line">$4 = 9</div><div class="line">(gdb) print result</div><div class="line">$5 = 45</div><div class="line">(gdb)</div><div class="line">$6 = 45</div><div class="line">(gdb) p i</div><div class="line">$7 = 9</div></pre></td></tr></table></figure>
</li>
<li><p>执行到下个断点，continue或c，没有断点程序结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  (gdb) continue</div><div class="line">Continuing.</div><div class="line">result[1-100]=5050</div><div class="line">[Inferior 1 (process 3674) exited normally]</div></pre></td></tr></table></figure>
</li>
<li><p>查看程序调用栈信息，当前执行到sum函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  (gdb) bt</div><div class="line">#0  sum (n=100) at test.c:6</div><div class="line">#1  0x0000000000400577 in main (argv=1, args=0x7fffffffe2b8) at test.c:22</div></pre></td></tr></table></figure>
</li>
<li><p>退出当前函数，finish</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  (gdb) finish</div><div class="line">Run till exit from #0  sum (n=100) at test.c:6</div><div class="line">0x0000000000400577 in main (argv=1, args=0x7fffffffe2b8) at test.c:22</div><div class="line">22	    printf(&quot;result[1-100]=%d\n&quot;,sum(100));</div><div class="line">Value returned is $10 = 5050</div><div class="line">(gdb) n</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="gdb进阶-1"><a href="#gdb进阶-1" class="headerlink" title="gdb进阶"></a>gdb进阶</h4><p>一般来说，调试程序时需要编译器带-g参数，如果没有-g，将看不到程序的函数名，变量名，所替代将是运行时的内存地址。<br>启动gdb的方法有以下几种：</p>
<ol>
<li>gdb &lt;program&gt;  带调试信息的program程序。</li>
<li>gdb &lt;program&gt; core core文件是program程序非法执行后生产的文件，可以用它还原程序崩溃现场。</li>
<li>gdb &lt;program&gt; &lt;PID&gt; 调试一个正常运行的进程，gdb会自动attach上去并调试它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sudo gdb /usr/local/nginx/sbin/nginx 3832</div><div class="line">(gdb) quit</div><div class="line">A debugging session is active.</div><div class="line"></div><div class="line">	Inferior 1 [process 3832] will be detached.</div><div class="line"></div><div class="line">Quit anyway? (y or n) y</div><div class="line">Detaching from program: /usr/local/nginx/sbin/nginx, process 3832</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在gdb准备执行run或r指令前，可以对一些环境参数进行设置：</p>
<ol>
<li><p>程序运行参数。<br>set args 指定运行时参数。如：set arg 1 2 3 4<br>show args 可以查看设置好的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  (gdb) set args 1 2 3 4</div><div class="line">(gdb) show args</div><div class="line">Argument list to give program being debugged when it is started is &quot;1 2 3 4&quot;.</div></pre></td></tr></table></figure>
</li>
<li><p>程序工作路径<br>path &lt;dir&gt; 添加程序的工作路径<br>show paths<br>当前目录被添加到了工作路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  (gdb) path .</div><div class="line">Executable and object file path: /home/highsung/dev/lesson_9:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/highsung/.local/bin:/home/highsung/bin</div><div class="line">(gdb) show paths</div><div class="line">Executable and object file path: /home/highsung/dev/lesson_9:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/highsung/.local/bin:/home/highsung/bin</div></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量<br>set environment varname=[value] 设置环境变量<br>show environment [varname] 查看环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  (gdb) set env XM1=111</div><div class="line">(gdb) show env XM1</div><div class="line">XM1 = 111</div><div class="line">(gdb) show env</div><div class="line">XDG_VTNR=1</div><div class="line">SSH_AGENT_PID=1183</div><div class="line">...</div><div class="line">LINES=24</div><div class="line">COLUMNS=80</div><div class="line">XM1=111</div></pre></td></tr></table></figure>
</li>
<li><p>程序的输入输出<br>info terminal 显示程序用到的终端模式，可以重定向到某个文件，如run &gt; outfile<br>也可用tty 命令指定输入输出的终端设备。如 tty /dev/ttyb</p>
</li>
</ol>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_9/20170323135654.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/22/course/embeded/lesson_9/" data-id="cj1zsm1ra001crkufhj25o6nr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-course/embeded/lesson_8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/21/course/embeded/lesson_8/" class="article-date">
  <time datetime="2017-03-21T08:51:00.000Z" itemprop="datePublished">2017-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/21/course/embeded/lesson_8/">（8）gcc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="gcc简介"><a href="#gcc简介" class="headerlink" title="gcc简介"></a>gcc简介</h4><h4 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h4><h4 id="gcc编译object-c"><a href="#gcc编译object-c" class="headerlink" title="gcc编译object-c"></a>gcc编译object-c</h4><hr>
<p><img src="http://omn7bkwg7.bkt.clouddn.com/images/course/embeded/lesson_8/link.jpg" alt="image"></p>
<h5 id="gcc简介-1"><a href="#gcc简介-1" class="headerlink" title="gcc简介"></a>gcc简介</h5><h6 id="GCC-the-GNU-Compiler-Collection"><a href="#GCC-the-GNU-Compiler-Collection" class="headerlink" title="GCC, the GNU Compiler Collection"></a><a href="http://gcc.gnu.org/" target="_blank" rel="external">GCC</a>, the GNU Compiler Collection</h6><p>The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Ada, and Go, as well as libraries for these languages (libstdc++,…). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user’s freedom.</p>
<p>GCC是GNU编译器集合。GNU编译器集合包括C，C ++，Objective-C，Fortran，Ada和Go的前端，以及这些语言的库（libstdc++，…）。 GCC最初是作为GNU操作系统的编译器编写的。 GNU系统被开发为100％免费的软件，它在尊重用户自由的意义上是免费的。</p>
<ul>
<li>gcc常用指令</li>
</ul>
<ol>
<li><p>检测gcc是否安装及版本号，若未安装gcc会提示“未找到命令”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gcc -v</div><div class="line">使用内建 specs。</div><div class="line">COLLECT_GCC=gcc</div><div class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/6.2.1/lto-wrapper</div><div class="line">目标：x86_64-redhat-linux</div><div class="line">配置为：../configure ...</div><div class="line">线程模型：posix</div><div class="line">gcc 版本 6.2.1 20160916 (Red Hat 6.2.1-2) (GCC)</div></pre></td></tr></table></figure>
</li>
<li><p>编写hello.c程序，内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argv, char *arg[])</div><div class="line">&#123;</div><div class="line">  printf(&quot;%s&quot;,&quot;hello gcc!\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译hello.c，生成a.out文件，执行之输出“hello gcc!”。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c</div><div class="line">$ ls</div><div class="line">a.out  hello.c</div><div class="line">$ ./a.out</div><div class="line">hello gcc!</div></pre></td></tr></table></figure>
</li>
<li><p>gcc常用编译选项</p>
</li>
</ol>
<ul>
<li><p>-o 指定编译生成的可执行程序名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c -o hello.exe</div><div class="line">$ ls</div><div class="line">a.out  hello.c  hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>-g 告诉编译器生成调试信息，如下，包含调试信息的hello.exe比a.out大一些。<br>用gdb调试程序时，程序必须包含调试信息才能调试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc hello.c -o hello.exe -g</div><div class="line">$ ls -al</div><div class="line">总用量 36</div><div class="line">-rwxrwxr-x. 1 highsung highsung  8528 3月  21 17:12 a.out</div><div class="line">-rw-rw-r--. 1 highsung highsung    97 3月  21 17:12 hello.c</div><div class="line">-rwxrwxr-x. 1 highsung highsung 11048 3月  21 17:29 hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>也可通过strip命令去除hello.exe中的调试信息，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ strip -g hello.exe</div><div class="line">$ ls -al</div><div class="line">总用量 36</div><div class="line">drwxrwxr-x. 2 highsung highsung 4096 3月  21 17:33 .</div><div class="line">drwxrwxr-x. 3 highsung highsung 4096 3月  21 17:08 ..</div><div class="line">-rwxrwxr-x. 1 highsung highsung 8528 3月  21 17:12 a.out</div><div class="line">-rw-rw-r--. 1 highsung highsung   97 3月  21 17:12 hello.c</div><div class="line">-rwxrwxr-x. 1 highsung highsung 8416 3月  21 17:33 hello.exe</div></pre></td></tr></table></figure>
</li>
<li><p>-static 以静态链接方式生成可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gcc -static hello.c -o a1</div><div class="line">/bin/ld: 找不到 -lc</div></pre></td></tr></table></figure>
<p>缺少静态包glibc-static，安装glibc-static后编译运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ dnf install -y glibc-static</div><div class="line">$ gcc -static hello.c -o a1</div><div class="line">$ ls -al</div><div class="line">-rwxrwxr-x. 1 highsung highsung   8480 3月  21 19:24 a</div><div class="line">-rwxrwxr-x. 1 highsung highsung 917632 3月  21 19:21 a1</div></pre></td></tr></table></figure>
<p>发现a1的大小比a大得多。因为a程序所依赖的程序指令全部打包到了a1中。<br>那么如何查看a所依赖的动态库？用ldd命令查看，如下。<br>显示a依赖3个动态库，动态库名字so.m.n结尾，so代表是动态库，m.n代表主次版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> $ ldd a</div><div class="line">linux-vdso.so.1 (0x00007ffc56d8e000)</div><div class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f09b1516000)</div><div class="line">/lib64/ld-linux-x86-64.so.2 (0x000055fcc140f000)</div><div class="line"> 这里提示a1不是一个动态执行文件</div><div class="line"> $ ldd a1</div><div class="line">not a dynamic executable</div><div class="line"> 用file命令查看，a1是静态链接方式。</div><div class="line"> $ file a1</div><div class="line"> a1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=686f47857cae85c959c39301843029ee1e98467e, not stripped</div></pre></td></tr></table></figure>
</li>
<li><p>-Idir 指定编译时，搜索头文件路径。<br>用 #include &lt;file.h&gt;时，gcc会在-I指定的目录中查找file.h，查找不到时，到缺省目录/usr/include/中查找。<br>用 #include “file.h”时，gcc会在当前目录下查找file.h，查找不到时，再按上面的顺序查找。</p>
</li>
<li><p>-include file.h，功能相当于在代码中使用#include &lt;file.h&gt;</p>
</li>
<li><p>-Ldir 指定链接时，搜索库的路径。默认库的路径在/usr/lib，/usr/lib64<br>例子如下，在当前目录下my/lib搜索库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -L./my/lib hello.c</div></pre></td></tr></table></figure>
</li>
<li><p>-llibrary 指定编译时候链接的库<br>例子如下，使用curses库链接程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -lcurses hello.c</div></pre></td></tr></table></figure>
</li>
<li><p>-O0 -O1 -O2 -O3，编译器优化的4个级别，-O0没有优化，-O1缺省优化，-O3最高级别优化。</p>
</li>
</ul>
<h5 id="程序编译过程-1"><a href="#程序编译过程-1" class="headerlink" title="程序编译过程"></a>程序编译过程</h5><p>gcc和g++执行编译工作的时候，总共需要4步：</p>
<ol>
<li>预处理，生成.i文件。-E选项激活</li>
<li>将预处理的文件转换成汇编语言，生成.s文件。-S选项激活</li>
<li>汇编指令转换成目标代码（机器代码），生成.o文件。-c选项激活</li>
<li>链接目标代码，生成可执行程序。-o选项激活<br>每一步的编译指令如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ gcc -E hello.c &gt;&gt; hello.i</div><div class="line">$ gcc -S hello.c</div><div class="line">$ gcc -c hello.c</div><div class="line">$ gcc -o hello hello.c</div><div class="line">$ ls -al</div><div class="line">-rwxrwxr-x. 1 highsung highsung   8480 3月  21 23:05 hello</div><div class="line">-rw-rw-r--. 1 highsung highsung     97 3月  21 19:07 hello.c</div><div class="line">-rw-rw-r--. 1 highsung highsung  16878 3月  21 23:02 hello.i</div><div class="line">-rw-rw-r--. 1 highsung highsung   1504 3月  21 23:02 hello.o</div><div class="line">-rw-rw-r--. 1 highsung highsung    501 3月  21 23:01 hello.s</div></pre></td></tr></table></figure>
</li>
</ol>
<p>预处理包含哪些处理？</p>
<ol>
<li>展开 #include 包含的头文件</li>
<li>处理条件编译指令，#if #ifndef #endif 等</li>
<li>替换 #define 定义的各种宏</li>
<li>处理编译指令，#pragma pack，#line 等</li>
</ol>
<h5 id="编译Objective-C"><a href="#编译Objective-C" class="headerlink" title="编译Objective-C"></a>编译Objective-C</h5><ol>
<li><p>安装<a href="http://www.oschina.net/p/gnustep-org/" target="_blank" rel="external">gnustep</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install gnustep*</div></pre></td></tr></table></figure>
</li>
<li><p>安装gcc-objc，gcc调用它来执行编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install gcc-objc</div></pre></td></tr></table></figure>
</li>
<li><p>编写一个Objective-C的Hello world文件hello.m。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Hello world, Object-C!&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译并运行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -o hello hello.m -lobjc -lgnustep-base -fconstant-string-class=NSConstantString</div><div class="line">$ ./hello</div><div class="line">...</div><div class="line">2017-03-23 23:11:36.295 helloworld[5405:5405] Hello world, Object-C!</div></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/21/course/embeded/lesson_8/" data-id="cj1zsm1qy0014rkufau81lew2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-git/">hexo git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大学生实训/">大学生实训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式开发/">嵌入式开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/校园采风/">校园采风</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/hexo-git/" style="font-size: 10px;">hexo git</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/大学生实训/" style="font-size: 10px;">大学生实训</a> <a href="/tags/嵌入式开发/" style="font-size: 20px;">嵌入式开发</a> <a href="/tags/校园采风/" style="font-size: 10px;">校园采风</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/27/course/embeded/lesson_15/">（15）Uboot实验</a>
          </li>
        
          <li>
            <a href="/2017/04/27/course/embeded/lesson_14/">（14）Uboot</a>
          </li>
        
          <li>
            <a href="/2017/04/22/course/embeded/tip_1/">ubuntu apt-get install 加速</a>
          </li>
        
          <li>
            <a href="/2017/03/26/course/embeded/lesson_13/">（13）Linux内核编译</a>
          </li>
        
          <li>
            <a href="/2017/03/25/course/embeded/lesson_12/">（12）Linux字符驱动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 HighSung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>